var UndrAds = (function (exports) {
  'use strict';

  const isDebugMode = () => {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get('undr_debug') === 'true';
  };
  const isDevMode = () => {
    // Check if the URL contains 'localhost' or '127.0.0.1'
    return (
      window.location.href.includes('http://localhost') ||
      window.location.href.includes('http://127.0.0.1')
    );
  };

  class Logger {
    static instance;
    bannerShown = false;
    titleGradient = 'linear-gradient(90deg,rgb(136, 0, 255),rgb(177, 74, 195))';
    constructor() {}
    static getInstance() {
      Logger.instance ??= new Logger();
      return Logger.instance;
    }
    showWelcomeBanner() {
      if (this.bannerShown) return;
      this.bannerShown = true;
      const titleStyle = `
  background: ${this.titleGradient};
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  font-size: 1.8em;
  font-weight: bold;
  font-family: monospace;
`;
      const subtitleStyle = `
  color: #8BC34A;
  font-size: 1.2em;
  font-family: monospace;
  margin: 10px 0;
`;
      const horizontalLineStyle = `
  color: #555;
  font-size: 1em;
  font-family: monospace;
  margin: 10px 0;
`;
      const messageStyle = `
  color: #ddd;
  font-size: 1em;
  font-family: monospace;
  line-height: 1.5;
`;
      const highlightStyle = `
  color: #FFD700;
  font-weight: bold;
`;
      const emojiStyle = `
  color: #4CAF50;
  font-size: 1.2em;
  font-family: monospace;
  margin-top: 10px;
`;
      const hiddenCaretStyle = `
  color: #777;
  font-size: 0.8em;
  font-family: monospace;
  margin-top: 5px;
`;
      this.log(
        'INFO',
        `%cWelcome to the UndrAds Logs Portal!\n%cWe Optimize Publisher Revenue with Cutting-Edge AdTech!\n%c----------------------------------------------\n%cHere, you'll find all the logs you need to keep things running smoothly. If something seems broken, don't panic! Just email us at %csupport@undrads.com%c with a screenshot of the logs, or reach out to our AdOps team with the details.\n\n%cWe're on it like ads on a webpageâ€”your issues will be fixed in no time!\n%c----------------------------------------------n%cðŸ˜Š [Happy Debugging!] :)\n%c(Pro tip: Keep calm and debug on! - The UndrAds Dev Team)`,
        titleStyle,
        subtitleStyle,
        horizontalLineStyle,
        messageStyle,
        highlightStyle,
        messageStyle,
        messageStyle,
        horizontalLineStyle,
        emojiStyle,
        hiddenCaretStyle
      );
    }
    getTimestamp() {
      const now = new Date();
      return `${now.toLocaleTimeString([], {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
      })}`;
    }
    formatMessage(level) {
      const timestamp = this.getTimestamp();
      let emoji = '';
      switch (level) {
        case 'DEBUG':
          emoji = '';
          break;
        case 'INFO':
          emoji = '';
          break;
        case 'WARN':
          emoji = '';
          break;
        case 'ERROR':
          emoji = '';
          break;
        case 'SUCCESS':
          emoji = '';
          break;
      }
      return `%c[${timestamp}] %c[UndrAds] %c[${emoji} ${level}]`;
    }
    log(level, message, ...optionalParams) {
      if (!isDebugMode()) {
        return;
      }
      const error = new Error();
      const callerLine = error.stack?.split('\n')[3]?.trim() ?? 'unknown caller';
      const callerInfo = callerLine.trim().substring(3);
      const formattedMessage = this.formatMessage(level);
      const timestampStyle = 'color: gray; font-weight: bold;';
      const undrAdsStyle = `
    background: ${this.titleGradient};
    color: white;
    padding: 2px 4px;
    border-radius: 4px;
    font-weight: bold;
  `;
      const levelStyle = `
    background: ${this.getBadgeGradient(level)};
    color: white;
    padding: 2px 4px;
    border-radius: 4px;
    font-weight: bold;
  `;
      const dividerStyle = 'color: gray; font-size: 0.9em;';
      const messageStyle = 'font-size: 1.2em; font-weight: bold;';
      const callerStyle = 'color: gray; font-size: 0.8em;';
      console.log(
        `${formattedMessage}\n%c----------------------------------------------\n%c${message}\n%c----------------------------------------------\n%c${callerInfo}`,
        timestampStyle,
        undrAdsStyle,
        levelStyle,
        dividerStyle,
        messageStyle,
        dividerStyle,
        callerStyle,
        ...optionalParams
      );
    }
    getBadgeGradient(level) {
      switch (level) {
        case 'DEBUG':
          return 'linear-gradient(90deg, purple, teal)';
        case 'INFO':
          return 'linear-gradient(90deg, darkgray, lightgray)';
        case 'WARN':
          return 'linear-gradient(90deg, darkorange, orange)';
        case 'ERROR':
          return 'linear-gradient(90deg, darkred, red)';
        case 'SUCCESS':
          return 'linear-gradient(90deg, darkgreen, green)';
        default:
          return 'linear-gradient(90deg, white, white)';
      }
    }
    debug(message, ...optionalParams) {
      this.log('DEBUG', message, ...optionalParams);
    }
    info(message, ...optionalParams) {
      this.log('INFO', message, ...optionalParams);
    }
    warn(message, ...optionalParams) {
      this.log('WARN', message, ...optionalParams);
    }
    error(message, ...optionalParams) {
      this.log('ERROR', message, ...optionalParams);
    }
    success(message, ...optionalParams) {
      this.log('SUCCESS', message, ...optionalParams);
    }
  }
  var logger = Logger.getInstance();

  /**
   * Class to handle interstitial ads.
   */
  class InterstitialAd {
    /**
     * Constructor for the InterstitialAd class.
     * @param adUnit
     * @param elementId
     */
    constructor(adUnit, elementId) {
      this.adUnit = adUnit;
      this.elementId = elementId;
    }
    /**
     * Initializes an interstitial ad unit.
     * @returns {googletag.Slot} The GPT slot for the interstitial ad.
     */
    init() {
      var _a, _b, _c;
      logger.debug(`Starting setting up interstitial ad ${this.elementId}`);
      const interstitialSlot = googletag.defineOutOfPageSlot(
        this.adUnit.code,
        googletag.enums.OutOfPageFormat.INTERSTITIAL
      );
      if (!interstitialSlot) {
        logger.error(`Failed to create interstitial slot for ${this.adUnit.code}`);
        return;
      }
      interstitialSlot.addService(googletag.pubads()).setConfig({
        interstitial: { triggers: { unhideWindow: true } },
      });
      googletag.pubads().addEventListener('slotOnload', (event) => {
        if (event.slot === interstitialSlot) {
          logger.debug(`Interstitial ad loaded for ${this.elementId}`);
        }
      });
      if (
        ((_b = (_a = this.adUnit.mediaTypes) === null || _a === void 0 ? void 0 : _a.banner) ===
          null || _b === void 0
          ? void 0
          : _b.sizes) != null
      ) {
        (_c = googletag.defineSlot(
          this.adUnit.code,
          this.adUnit.mediaTypes.banner.sizes,
          this.elementId
        )) === null || _c === void 0
          ? void 0
          : _c.addService(googletag.pubads());

        googletag.pubads().enableSingleRequest();
        googletag.enableServices();
      }
      return interstitialSlot;
    }
  }

  /**
   * @fileoverview Defines the type for ad unit configurations.
   */
  /**
   * Represents the type of an ad unit.
   * - STRUCTURAL: Also known as banner ads, most common type of ad.
   * - STICKY: The ad unit that is sticky. Sticky position can be top, bottom, left, right.
   * - INTERSTITIAL: It is a full-screen ad, when user wants to go out of the page.
   * - VIDEO: The ad unit that is a video, and it is played in a video player.
   * - DOCKED: The ad unit that is docked. A bit different from sticky ads.
   * - CHAINED: A docked ad unit that is chained to another ad unit and changes on scroll.
   */
  var AdType;
  (function (AdType) {
    AdType['STRUCTURAL'] = 'structural';
    AdType['STICKY'] = 'sticky';
    AdType['INTERSTITIAL'] = 'interstitial';
    AdType['VIDEO'] = 'video';
    AdType['DOCKED'] = 'docked';
    AdType['CHAINED'] = 'chained';
  })(AdType || (AdType = {}));

  /**
   * @fileoverview Defines the type for bidder configurations.
   */

  /**
   * Represents the device type for an ad unit.
   */
  var DeviceType;
  (function (DeviceType) {
    DeviceType['DESKTOP'] = 'desktop';
    DeviceType['MOBILE'] = 'mobile';
  })(DeviceType || (DeviceType = {}));

  /**
   * @fileoverview Exports all type definitions from the types directory.
   */

  /**
   * @fileoverview Global constants used throughout the UndrAds script.
   */
  // ?[start]?
  const biddersUNDR = [
    {
      bidder: 'oftmedia',
      params: {
        placementId: '33975359',
      },
    },
    {
      bidder: 'nobid',
      params: {
        siteId: '163977',
      },
    },
    {
      bidder: 'smilewanted',
      params: {
        zoneId: 'undrads.com_hb_display',
      },
    },
    {
      bidder: 'richaudience',
      params: {
        pid: 'a3O8Lk7XEI',
        supplyType: 'site',
      },
    },
    {
      bidder: 'rubicon',
      params: {
        siteId: '458326',
        zoneId: '3755742',
        accountId: '24872',
      },
    },
    {
      bidder: 'smartadserver',
      params: {
        pageId: '2064273',
        siteId: '698912',
        formatId: '108513',
        networkId: '4164',
      },
    },
    {
      bidder: 'appnexus',
      params: {
        placementId: '35482573',
      },
    },
    {
      bidder: 'pubmatic',
      params: {
        adSlot: '6852003',
        publisherId: '159941',
      },
    },
    {
      bidder: 'adsolut',
      params: {
        zoneId: '261264',
        host: 'cpm.adsolut.in',
      },
    },
    {
      bidder: 'mediafuse',
      params: {
        placementId: '35518453',
      },
    },
    {
      bidder: 'nextMillennium',
      params: {
        placement_id: '67590',
      },
    },
  ];

  const TagAdUnitUNDR_INDIA = {
    'UNDR/2358294094/adunit/mobile/320X50/03abaefd-4f45-42f5-bf95-472a19a7ea10': {
      code: '/23186024635/23297601909',
      mediaTypes: {
        banner: {
          sizes: [
            [320, 50],
            [300, 50],
          ],
          native: {
            type: 'image',
          },
        },
      },
      headerBidding: 'on',
      refresh: {
        status: 'on',
        time: 30,
      },
    },
    'UNDR/2358294094/adunit/desktop/336X280/0a81761e-b229-4eac-87ee-793b8dd3d596': {
      code: '/23186024635/23297605113',
      mediaTypes: {
        banner: {
          sizes: [
            [336, 280],
            [300, 250],
            [320, 100],
            [300, 100],
            [320, 50],
            [300, 50],
            [250, 250],
          ],
          native: {
            type: 'image',
          },
        },
      },
      headerBidding: 'on',
      refresh: {
        status: 'on',
        time: 30,
      },
    },
    'UNDR/2358294094/adunit/desktop/336X280/20bbb735-f3c0-44b6-aa62-01a1463694e2': {
      code: '/23186024635/23297605116',
      mediaTypes: {
        banner: {
          sizes: [
            [336, 280],
            [300, 250],
            [320, 100],
            [300, 100],
            [320, 50],
            [300, 50],
            [250, 250],
          ],
          native: {
            type: 'image',
          },
        },
      },
      headerBidding: 'on',
      refresh: {
        status: 'on',
        time: 30,
      },
    },
    'UNDR/2358294094/adunit/desktop/336X280/3d28e09d-ddd5-45d8-8f07-9b3a247b7938': {
      code: '/23186024635/23297605119',
      mediaTypes: {
        banner: {
          sizes: [
            [336, 280],
            [300, 250],
            [320, 100],
            [300, 100],
            [320, 50],
            [300, 50],
            [250, 250],
          ],
          native: {
            type: 'image',
          },
        },
      },
      headerBidding: 'on',
      refresh: {
        status: 'on',
        time: 30,
      },
    },
    'UNDR/2358294094/adunit/desktop/336X280/44828975-6f36-4624-b80f-c9b2add8a834': {
      code: '/23186024635/23297597799',
      mediaTypes: {
        banner: {
          sizes: [
            [300, 600],
            [336, 280],
            [300, 250],
            [320, 100],
            [300, 100],
            [320, 50],
            [300, 50],
            [250, 250],
          ],
          native: {
            type: 'image',
          },
        },
      },
      headerBidding: 'on',
      refresh: {
        status: 'on',
        time: 30,
      },
    },
    'UNDR/2358294094/adunit/desktop/336X280/44e505ed-352c-4316-9bfc-ebd646d05e96': {
      code: '/23186024635/23297605125',
      mediaTypes: {
        banner: {
          sizes: [
            [336, 280],
            [300, 250],
            [320, 100],
            [300, 100],
            [320, 50],
            [300, 50],
            [250, 250],
          ],
          native: {
            type: 'image',
          },
        },
      },
      headerBidding: 'on',
      refresh: {
        status: 'on',
        time: 30,
      },
    },
    'UNDR/2358294094/adunit/desktop/336X280/47c1a684-5d9b-4c1b-b5fc-a555c3211356': {
      code: '/23186024635/23297605131',
      mediaTypes: {
        banner: {
          sizes: [
            [336, 280],
            [300, 250],
            [320, 100],
            [300, 100],
            [320, 50],
            [300, 50],
            [250, 250],
          ],
          native: {
            type: 'image',
          },
        },
      },
      headerBidding: 'on',
      refresh: {
        status: 'on',
        time: 30,
      },
    },
    'UNDR/2358294094/adunit/mobile/300X250/4d2c7dcf-b809-4f6a-b0d3-9a91888b8537': {
      code: '/23186024635/23297605134',
      mediaTypes: {
        banner: {
          sizes: [
            [300, 250],
            [300, 100],
            [300, 50],
            [250, 250],
          ],
          native: {
            type: 'image',
          },
        },
      },
      headerBidding: 'on',
      refresh: {
        status: 'on',
        time: 30,
      },
    },
    'UNDR/2358294094/adunit/mobile/300X250/55bed025-34be-4f5e-9b2c-eacc78d58e82': {
      code: '/23186024635/23297605140',
      mediaTypes: {
        banner: {
          sizes: [
            [300, 250],
            [300, 100],
            [300, 50],
            [250, 250],
          ],
          native: {
            type: 'image',
          },
        },
      },
      headerBidding: 'on',
      refresh: {
        status: 'on',
        time: 30,
      },
    },
    'UNDR/2358294094/adunit/mobile/320X100/5c9b8c12-4e98-4700-9eb4-a2cec8b9f3b4': {
      code: '/23186024635/23297605143',
      mediaTypes: {
        banner: {
          sizes: [
            [320, 100],
            [320, 50],
            [300, 100],
            [300, 50],
          ],
          native: {
            type: 'image',
          },
        },
      },
      headerBidding: 'on',
      refresh: {
        status: 'on',
        time: 30,
      },
    },
    'UNDR/2358294094/adunit/desktop/336X280/692a6aae-8095-4c8d-82d4-5cd6607877e9': {
      code: '/23186024635/23297605146',
      mediaTypes: {
        banner: {
          sizes: [
            [336, 280],
            [300, 250],
            [320, 100],
            [300, 100],
            [320, 50],
            [300, 50],
            [250, 250],
          ],
          native: {
            type: 'image',
          },
        },
      },
      headerBidding: 'on',
      refresh: {
        status: 'on',
        time: 30,
      },
    },
    'UNDR/2358294094/adunit/desktop/300X250/7b90e17b-d20f-41c8-b1a0-fc7c6fb01df2': {
      code: '/23186024635/23297605152',
      mediaTypes: {
        banner: {
          sizes: [
            [300, 250],
            [300, 100],
            [300, 50],
            [250, 250],
          ],
          native: {
            type: 'image',
          },
        },
      },
      headerBidding: 'on',
      refresh: {
        status: 'on',
        time: 30,
      },
    },
    'UNDR/2358294094/adunit/mobile/300X250/80db8bd5-a4b7-4752-95df-495a357b8ec9': {
      code: '/23186024635/23297605158',
      mediaTypes: {
        banner: {
          sizes: [
            [300, 250],
            [300, 100],
            [300, 50],
            [250, 250],
          ],
          native: {
            type: 'image',
          },
        },
      },
      headerBidding: 'on',
      refresh: {
        status: 'on',
        time: 30,
      },
    },
    'UNDR/2358294094/adunit/mobile/300X250/9c44ebd3-3e4d-4ff8-9441-9f1e98109194': {
      code: '/23186024635/23297605164',
      mediaTypes: {
        banner: {
          sizes: [
            [300, 250],
            [300, 100],
            [300, 50],
            [250, 250],
          ],
          native: {
            type: 'image',
          },
        },
      },
      headerBidding: 'on',
      refresh: {
        status: 'on',
        time: 30,
      },
    },
    'UNDR/2358294094/adunit/desktop/300X600/a2747c5a-b0db-40ef-8e3a-eb18d6dae972': {
      code: '/23186024635/23297605167',
      mediaTypes: {
        banner: {
          sizes: [
            [300, 600],
            [160, 600],
            [120, 300],
            [300, 250],
            [300, 100],
          ],
          native: {
            type: 'image',
          },
        },
      },
      headerBidding: 'on',
      refresh: {
        status: 'on',
        time: 30,
      },
    },
    'UNDR/2358294094/adunit/desktop/728X250/a27bc5b6-536e-4adb-b117-8337f2173bca': {
      code: '/23186024635/23296517689',
      mediaTypes: {
        banner: {
          sizes: [
            [728, 250],
            [336, 280],
            [300, 250],
            [320, 100],
            [300, 100],
            [728, 90],
          ],
          native: {
            type: 'image',
          },
        },
      },
      headerBidding: 'on',
      refresh: {
        status: 'on',
        time: 30,
      },
    },
    'UNDR/2358294094/adunit/desktop/728X90/d215b490-b93a-4cc6-bd78-2af1f29cbf7c': {
      code: '/23186024635/23297605176',
      mediaTypes: {
        banner: {
          sizes: [
            [728, 90],
            [468, 60],
            [320, 50],
            [300, 50],
          ],
          native: {
            type: 'image',
          },
        },
      },
      headerBidding: 'on',
      refresh: {
        status: 'on',
        time: 30,
      },
    },
    'UNDR/2358294094/adunit/mobile/320X50/e3410d66-7179-4981-921a-1759868961c6': {
      code: '/23186024635/23296517692',
      mediaTypes: {
        banner: {
          sizes: [
            [320, 50],
            [300, 50],
          ],
          native: {
            type: 'image',
          },
        },
      },
      headerBidding: 'on',
      refresh: {
        status: 'on',
        time: 30,
      },
    },
    'UNDR/2358294094/undrads_adunit_tp/desktop/320X100/ed5315e6-ec12-4e2a-95da-4b4229dc9c95': {
      code: '/23186024635/23297605185',
      mediaTypes: {
        banner: {
          sizes: [
            [320, 100],
            [320, 50],
            [300, 100],
            [300, 50],
          ],
          native: {
            type: 'image',
          },
        },
      },
      headerBidding: 'on',
      refresh: {
        status: 'on',
        time: 30,
      },
    },
    'UNDR/2358294094/adunit/desktop/300X250/eea6bba7-39c6-41e9-82c5-7e16c17d92e4': {
      code: '/23186024635/23297605188',
      mediaTypes: {
        banner: {
          sizes: [
            [300, 250],
            [300, 100],
            [300, 50],
            [250, 250],
          ],
          native: {
            type: 'image',
          },
        },
      },
      headerBidding: 'on',
      refresh: {
        status: 'on',
        time: 30,
      },
    },
    'UNDR/2358294094/adunit/desktop/300X250/f1bde1a7-ba8d-4f01-8298-0fd81209503b': {
      code: '/23186024635/23297605194',
      mediaTypes: {
        banner: {
          sizes: [
            [300, 250],
            [300, 100],
            [300, 50],
            [250, 250],
          ],
          native: {
            type: 'image',
          },
        },
      },
      headerBidding: 'on',
      refresh: {
        status: 'on',
        time: 30,
      },
    },
  };

  const DockedAdUnitUNDR = { chained: 'off', xpath: '', adUnits: {} };
  const MobileToDesktopAdSizeMappingUNDR = {};
  const DesktopToMobileAdSizeMappingUNDR = {};
  const replaceExternalAdsUNDR = [];
  const replaceExternalAdsTimeoutUNDR = 30000;
  const isReplaceExternalAdsEnabledUNDR = false;
  const refreshExternalAdsUNDR = [];
  const isRefreshExternalAdsEnabledUNDR = false;
  const refreshExternalAdsTimeoutUNDR = 30000;
  const headerBiddingExternalAdsUNDR = [];
  const isHeaderBiddingExternalAdsUNDR = false;
  const isEmptyExternalAdsReplaceEnabledUNDR = true;
  const replaceUnfilledExternalAdTimeoutUNDR = 3000;
  const includedLineItemIdUNDR = [];
  const excludedLineItemIdUNDR = [];
  const urlBlockUNDR = [];
  const prebidTimeoutUNDR = 3000;
  const failSafeTimeoutUNDR = 3000;
  const publisherDomainUNDR = 'tutorialspoint.com';
  const publisherUrlUNDR = 'tutorialspoint.com';
  const gtagUserIdUNDR = 'G-4Z962XF55M';
  const isStructuralAdsEnabledUNDR = true;
  const isAmazonEnabledUNDR = false;
  const isVideoAdsEnabledUNDR = false;
  const isInterstitialAdsEnabledUNDR = false;
  const isStickyAdsEnabledUNDR = false;
  const isDockedAdsEnabledUNDR = false;
  const amazonPubIdUNDR = '5d8ed25e-57cc-441a-b62a-127b34faae4e';
  const adRefreshUNDR = true;
  const adLazyLoadingUNDR = false;
  const videoAdAutoplayUNDR = true;
  const floaterVideoAutoplayUNDR = true;
  const videoMutedUNDR = true;
  const floaterVideoUNDR = true;
  const isConsentManagementEnabledUNDR = true;
  const biddersCountryIncludedUNDR = {
    Japan: ['smilewanted'],
    'United Arab Emirates': ['smilewanted'],
    Sweden: ['smilewanted'],
    Austria: ['smilewanted'],
    Australia: ['smilewanted'],
    'South Africa': ['smilewanted'],
    Poland: ['smilewanted', 'oftmedia'],
    France: ['smilewanted'],
    Norway: ['smilewanted'],
    Canada: ['smilewanted', 'oftmedia'],
    Denmark: ['smilewanted'],
    Singapore: ['smilewanted'],
    Italy: ['smilewanted'],
    Germany: ['smilewanted'],
    Switzerland: ['smilewanted'],
    'United States': ['smilewanted', 'oftmedia'],
    'The Netherlands': ['smilewanted', 'oftmedia'],
    'United Kingdom': ['smilewanted', 'oftmedia'],
    Belgium: ['smilewanted', 'oftmedia'],
    Brazil: ['oftmedia'],
    Spain: ['smilewanted'],
    '*': [
      'ix',
      'onetag',
      'freewheelssp',
      'mediafuse',
      'yieldmo',
      'pubmatic',
      'selectmedia',
      'brightcom',
      'artechnology',
      'sovrn',
      'triplelift',
      'nobid',
      'pulsepoint',
      'sonobi',
      'luponmedia',
      'appnexus',
      'smartadserver',
      'improvedigital',
      'adyoulike',
      'teads',
      'spotx',
      'richaudience',
      'medianet',
      'fluct',
      'rubicon',
      'adsolut',
      'outbrain',
      'consumable',
      'yahooAds',
      'sharethrough',
      'justpremium',
      'criteo',
      'openx',
      'nextMillennium',
    ],
  };
  // ?[end]?

  function getAdUnitsWithBidders(config = { countryLevel: false, country: 'N/A' }) {
    const adUnits = TagAdUnitUNDR_INDIA;

    if (config.countryLevel) {
      // Get default bidders (marked with '*')
      const defaultBidders = biddersCountryIncludedUNDR['*'] ?? [];

      // Get country-specific bidders
      const countrySpecificBidders = biddersCountryIncludedUNDR[config.country] ?? [];

      // Combine default and country-specific bidders, removing duplicates
      const allowedBidders = [...new Set([...defaultBidders, ...countrySpecificBidders])];

      // Filter bidders based on the combined allowed list
      const filteredBidders = Object.values(biddersUNDR).filter((value) =>
        allowedBidders.includes(value.bidder)
      );

      return Object.fromEntries(
        Object.entries(adUnits).map(([key, adUnit]) => [
          key,
          { ...adUnit, bids: [...filteredBidders] },
        ])
      );
    }

    return Object.fromEntries(
      Object.entries(adUnits).map(([key, adUnit]) => [key, { ...adUnit, bids: biddersUNDR }])
    );
  }

  /**
   * Global configuration for the ad script.
   */
  const CONFIG = {
    BIDDERS: biddersUNDR,
    /**
     * Transform the Ad Units to include Bidders in the Main Ad Units
     */
    AD_UNITS: getAdUnitsWithBidders({ countryLevel: true, country: 'N/A' }),
    /**
     * Transform the Docked Ad Units to include Bidders in the Docked Ad Units
     */
    DOCKED_AD_UNITS: {
      ...DockedAdUnitUNDR,
      adUnits: Object.fromEntries(
        Object.entries(DockedAdUnitUNDR.adUnits).map(([key, adUnit]) => [
          key,
          { ...adUnit, bids: biddersUNDR },
        ])
      ),
    },
    /**
     * Transform the Header Bidding External Ad Units to include Bidders in the Header Bidding External Ad Units
     */
    HEADER_BIDDING_EXTERNAL_ADS: headerBiddingExternalAdsUNDR.map((adUnit) => ({
      ...adUnit,
      bids: biddersUNDR,
    })),
    /**
     * Ad size mapping for mobile and desktop devices.
     */
    AD_SIZE_MAPPING: {
      MOBILE_TO_DESKTOP: MobileToDesktopAdSizeMappingUNDR,
      DESKTOP_TO_MOBILE: DesktopToMobileAdSizeMappingUNDR,
    },
    REPLACE_EXTERNAL_ADS: replaceExternalAdsUNDR,
    REFRESH_EXTERNAL_ADS: refreshExternalAdsUNDR,
    INCLUDED_LINE_ITEM_ID: includedLineItemIdUNDR,
    EXCLUDED_LINE_ITEM_ID: excludedLineItemIdUNDR,
    URL_BLOCK: urlBlockUNDR,
    /**
     * Status of various features and services.
     * - ADS: Status of different ad types.
     * - SERVICES: Status of different services.
     */
    STATUS: {
      ADS: {
        INTERSTITIAL: isInterstitialAdsEnabledUNDR,
        STICKY: isStickyAdsEnabledUNDR,
        STRUCTURAL: isStructuralAdsEnabledUNDR,
        AMAZON: isAmazonEnabledUNDR,
        VIDEO: isVideoAdsEnabledUNDR,
        DOCKED: isDockedAdsEnabledUNDR,
        PROPERTY: {
          FLOATER_VIDEO: floaterVideoUNDR,
          REFRESH: adRefreshUNDR,
          LAZY_LOADING: adLazyLoadingUNDR,
          VIDEO_AUTOPLAY: videoAdAutoplayUNDR,
          FLOATER_VIDEO_AUTOPLAY: floaterVideoAutoplayUNDR,
          VIDEO_MUTED: videoMutedUNDR,
          /**
           * If replace external ads is enabled, then refresh and header bidding will be disabled.
           * If header bidding is enabled, then replace external ads will be disabled.
           * If refresh is enabled, then replace external ads will be disabled.
           */
          REPLACE_EXTERNAL_ADS: isReplaceExternalAdsEnabledUNDR,
          REFRESH_EXTERNAL_ADS: isRefreshExternalAdsEnabledUNDR,
          EMPTY_EXTERNAL_ADS_REPLACE: isEmptyExternalAdsReplaceEnabledUNDR,
          HEADER_BIDDING_EXTERNAL_ADS: isHeaderBiddingExternalAdsUNDR,
          CONSENT_MANGEMENT: isConsentManagementEnabledUNDR,
        },
      },
      SERVICES: {
        GTAG: false,
        GPT: true,
        PREBID: true,
        IAB: true,
        ANALYTICS: true,
        PAGEVIEW: true,
      },
    },
    TIMEOUTS: {
      FAILSAFE: failSafeTimeoutUNDR,
      PREBID: prebidTimeoutUNDR,
      REFRESH: 30000,
      INIT: 2000,
      REPLACE_EXTERNAL_ADS: replaceExternalAdsTimeoutUNDR,
      REFRESH_EXTERNAL_ADS: refreshExternalAdsTimeoutUNDR,
      REPLACE_UNFILLED_EXTERNAL_AD: replaceUnfilledExternalAdTimeoutUNDR,
      HEADER_BIDDING_REFRESH_EXTERNAL_ADS: 30000,
    },
    GTAG_USER_ID: gtagUserIdUNDR,
    AMAZON_PUB_ID: amazonPubIdUNDR,
    ENDPOINTS: {
      GFC: 'https://fundingchoicesmessages.google.com/i/pub-8584156348842922?ers=1',
      GPT: 'https://securepubads.g.doubleclick.net/tag/js/gpt.js',
      PREBID: 'https://config.undrads.com/prebid_9_37_v2.js',
      GTAG: 'https://www.googletagmanager.com/gtag/js?id=' + gtagUserIdUNDR,
      IAB: 'https://prod.undrads.com/get_iab_id/',
      ANALYTICS: {
        HOST: 'analytics.undrads.com',
        PATHNAME: '/bidresponse/',
      },
      PAGEVIEW: 'https://analytics.undrads.com/bidpageview/',
    },
    COUNTRY: 'N/A',
    CURRENCY: {
      DEFAULT: 'USD',
      MULTIPLIER: 1,
    },
    PUBLISHER_DOMAIN: publisherDomainUNDR,
    PUBLISHER_URL: publisherUrlUNDR,
    MAX_UNFILLED_REFRESH_ATTEMPTS: 3,
    DEBUG_MODE: () => {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get('undr_debug') === 'true';
    },
  };

  /**
   * @fileoverview Provides various utility functions used in the ad script.
   */
  /**
   * Contains a set of utility functions for the ad script.
   */
  const utils = {
    /**
     * Create a alphanumeric hash string that can be used as a unique identifier.
     * @returns The generated hash string.
     */
    createHash: () => {
      return Math.random().toString(36).substring(2, 15);
    },
    /**
     * Get hashed id for the ad unit.
     * @param adUnitId - The ad unit id
     * @returns {AdUnitElementId} The hashed id for the ad container
     */
    getHashedId: (adUnitId) => adUnitId + '_ins_' + utils.createHash(),
    /**
     * Check if the device is a mobile device.
     * @returns True if the device is a mobile device, false otherwise.
     */
    isMobile: () => {
      return /Mobi|Android/i.test(navigator.userAgent);
    },
    /**
     * Is the device size of a mobile device.
     * @returns True if the device size is of a mobile device, false otherwise.
     */
    isMobileSize: () => window.innerWidth < 768,
    getAllInternalAdCodes: () => {
      const adCodes = Object.values(CONFIG.AD_UNITS).map((adUnit) => adUnit.code);
      return adCodes;
    },
    isInternalAdUnit: (adUnitCode) => utils.getAllInternalAdCodes().includes(adUnitCode),
    isExternalAdUnit: (adUnitCode) => !utils.isInternalAdUnit(adUnitCode),
    /**
     * Retrieves the advertisement unit ID specific to the given device type.
     *
     * @param device - The type of device for which the ad unit ID is to be retrieved.
     * @param newAdUnitSize - The new ad unit size to search for.
     * @param isCurrentAdUnitSticky - The sticky status of the current ad unit.
     * @returns The ad unit ID associated with the specified device type, or undefined if no matching ID is found.
     */
    getDeviceSpecificAdKey: (device, newAdUnitSize, isCurrentAdUnitSticky = 'off') => {
      var _a;
      let adUnitId = undefined;
      if (newAdUnitSize == null) {
        logger.error('No ad unit size provided');
        return undefined;
      }
      // Iterate over each ad unit and find the one that matches the search string
      for (const size of newAdUnitSize) {
        logger.debug('Searching for ad unit:', device, size);
        const searchString = device + '/' + size;
        for (const [key, value] of Object.entries(CONFIG.AD_UNITS)) {
          const isSticky = (_a = value.isSticky) !== null && _a !== void 0 ? _a : 'off';
          if (key.includes(searchString) && isSticky === isCurrentAdUnitSticky) {
            adUnitId = key;
            break;
          }
        }
      }
      return adUnitId !== null && adUnitId !== void 0 ? adUnitId : undefined;
    },
    getAdTypeFromClassName(adElement) {
      var _a;
      const classNames =
        (_a =
          adElement === null || adElement === void 0 ? void 0 : adElement.className.split(' ')) !==
          null && _a !== void 0
          ? _a
          : [];
      let adType = AdType.STRUCTURAL;
      for (const className of classNames) {
        if (className.includes('ua-video')) {
          adType = AdType.VIDEO;
          break;
        } else if (className.includes('ua-docked')) {
          adType = AdType.DOCKED;
          break;
        } else if (className.includes('ua-chained')) {
          adType = AdType.CHAINED;
          break;
        }
      }
      return adType;
    },
    getAdSizeFromElement(adId) {
      const adIdParts = adId.split('/');
      // Second last part of the ad ID is the ad size
      return adIdParts[adIdParts.length - 2];
    },
    /**
     * Get the data-ad-id from the ins element.
     * @param insElement - The ins element
     * @returns InternalAdUnitId - The ad unit ID
     */
    getElementAdId(insElement) {
      var _a;
      // Fetch data attribute data-ad-id from ins element, it can be a string or an array
      const dataAdId =
        (_a =
          insElement === null || insElement === void 0
            ? void 0
            : insElement.getAttribute('data-ad-id')) !== null && _a !== void 0
          ? _a
          : '';
      if (dataAdId === '') {
        logger.error('Ad unit does not have an ad ID');
        return null;
      }
      const elementAdId = dataAdId.split(',');
      // If the element has multiple ad units, get the first one
      return elementAdId[0];
    },
    /**
     * Takes an ad type and returns the corresponding class name.
     * @param adType - The ad type
     * @returns string
     * @example
     * getClassNameFromAdType(AdType.VIDEO) // 'ua-video'
     * getClassNameFromAdType(AdType.DOCKED) // 'ua-docked'
     */
    getClassNameFromAdType(adType) {
      switch (adType) {
        case AdType.VIDEO:
          return 'ua-video';
        case AdType.DOCKED:
          return 'ua-docked';
        case AdType.CHAINED:
          return 'ua-chained';
        default:
          return 'ua-display';
      }
    },
    /**
     * Creates a new Internal Ad element
     * @param internalAdUnitId - The Internal ad unit ID (e.g. UNDR/1234/desktop/728X90/ad-1)
     * @param adType - The ad type (e.g. AdType.STICKY)
     * @returns The new Internal Ad element
     * @example
     *  createAdElement('UNDR/1234/desktop/728X90/ad-1', AdType.STRUCTURAL) =>
     *  <ins class="undrads ua-display" data-ad-id="UNDR/1234/desktop/728X90/ad-1"> </ins>
     */
    createAdElement(internalAdUnitId, adType = AdType.STRUCTURAL) {
      const internalAdElement = document.createElement('ins');
      internalAdElement.className = `undrads ${this.getClassNameFromAdType(adType)}`;
      internalAdElement.setAttribute('data-ad-id', internalAdUnitId);
      internalAdElement.id = this.getHashedId(internalAdUnitId);
      return internalAdElement;
    },
    isScriptLoaded(src) {
      return document.querySelector(`script[src="${src}"]`) !== null;
    },
    isStylesheetLoaded(href) {
      return document.querySelector(`link[href="${href}"]`) !== null;
    },
    /**
     * Dynamically loads a JavaScript file from the given URL and
     * appends it to the document's head.
     *
     * @param url The URL of the script to load.
     * @returns A Promise that resolves when the script is loaded.
     */
    loadScript: (url) => {
      // Return immediately if script is already loaded
      if (utils.isScriptLoaded(url)) {
        logger.debug(`Script already loaded: ${url}`);
        return Promise.resolve();
      }
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = url;
        script.async = true;
        script.onload = () => {
          logger.debug(`Script loaded successfully: ${url}`);
          resolve();
        };
        script.onerror = () => {
          logger.error(`Error loading script: ${url}`);
          reject(new Error(`Failed to load script: ${url}`));
        };
        document.head.appendChild(script);
      });
    },
    /**
     * Dynamically loads a CSS file from the given URL and
     * appends it to the document's head.
     * @param url The URL of the CSS file to load.
     * @param attributes Additional attributes to apply to the link element.
     * @returns A Promise that resolves when the CSS file is loaded.
     */
    loadStyleSheet: (url, attributes = {}) => {
      // Return immediately if stylesheet is already loaded
      if (utils.isStylesheetLoaded(url)) {
        logger.debug(`Stylesheet already loaded: ${url}`);
        return Promise.resolve();
      }
      return new Promise((resolve, reject) => {
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = url;
        link.type = 'text/css';
        // Apply additional attributes
        for (const [key, value] of Object.entries(attributes)) link[key] = value;
        link.onload = () => {
          logger.debug(`Stylesheet loaded successfully: ${url}`);
          resolve();
        };
        link.onerror = () => {
          logger.error(`Error loading stylesheet: ${url}`);
          reject(new Error(`Failed to load stylesheet: ${url}`));
        };
        document.head.appendChild(link);
      });
    },
    /**
     * Creates a UUID (Universally Unique Identifier) based on the provided clientId.
     * @param clientId The client ID to use as the basis for the UUID.
     * @param limit The maximum length of the generated UUID.
     * @returns The generated UUID.
     */
    createUUID: (clientId, limit) => {
      let uuid = clientId.replace(/\./g, '');
      if (uuid.length > limit) {
        uuid = uuid.substring(0, limit);
      }
      return uuid;
    },
    /**
     * Retrieves details about the user's device, including:
     * - deviceName (e.g., "Mobile", "Desktop")
     * - browserName (e.g., "Chrome", "Firefox")
     * - operatingSystem (e.g., "Windows", "Mac OS")
     * - browserLanguage (e.g., "en-US")
     * @returns An object containing the device details.
     */
    getDeviceDetails: function () {
      const userAgent = navigator.userAgent;
      let browserName = 'Unknown';
      let operatingSystem = 'Unknown';
      let language = 'Unknown';
      // Detect browser
      if (userAgent.indexOf('Chrome') > -1) {
        browserName = 'Chrome';
      } else if (userAgent.indexOf('Firefox') > -1) {
        browserName = 'Firefox';
      } else if (userAgent.indexOf('Safari') > -1) {
        browserName = 'Safari';
      } else if (userAgent.indexOf('Opera') > -1) {
        browserName = 'Opera';
      } else if (userAgent.indexOf('MSIE') > -1) {
        browserName = 'IE';
      }
      // Detect operating system
      if (userAgent.indexOf('Windows') > -1) {
        operatingSystem = 'Windows';
      } else if (userAgent.indexOf('Mac OS') > -1) {
        operatingSystem = 'Mac OS';
      } else if (userAgent.indexOf('Linux') > -1) {
        operatingSystem = 'Linux';
      } else if (userAgent.indexOf('Android') > -1) {
        operatingSystem = 'Android';
      } else if (userAgent.indexOf('iOS') > -1) {
        operatingSystem = 'iOS';
      }
      // Get browser language
      language = navigator.language || navigator.userLanguage;
      // Determine device type
      const deviceType = this.isMobile() ? DeviceType.MOBILE : DeviceType.DESKTOP;
      return {
        deviceType,
        browserName,
        operatingSystem,
        browserLanguage: language,
      };
    },
    /**
     * Checks if the provided element is in the viewport.
     * @param element The element to check.
     * @param threshold The visibility threshold (0.0 - 1.0); default = 0.5 (50%).
     * @returns True if the element is in the viewport, false otherwise.
     */
    isInViewport: (element, threshold = 0.5) => {
      if (!element) {
        return false;
      }
      const rect = element.getBoundingClientRect();
      const windowHeight = window.innerHeight || document.documentElement.clientHeight;
      return (
        (rect.top >= 0 && rect.top <= windowHeight * threshold) ||
        (rect.bottom >= windowHeight * (1 - threshold) && rect.bottom <= windowHeight)
      );
    },
    /**
     * Throttles a function to prevent it from being called too often.
     * @param func The function to throttle.
     * @param delay The minimum time (in milliseconds) between function calls.
     * @returns The throttled function.
     */
    throttle: (func, delay) => {
      let timeoutId;
      let lastExec = 0;
      return function (...args) {
        const elapsed = Date.now() - lastExec;
        const exec = () => {
          lastExec = Date.now();
          func.apply(this, args);
        };
        clearTimeout(timeoutId);
        if (elapsed > delay) {
          exec();
        } else {
          timeoutId = setTimeout(exec, delay - elapsed);
        }
      };
    },
    /**
     * Asynchronously retrieves the country code from the CDN response headers.
     *
     * This function makes a HEAD request to the specified CDN URL and attempts to
     * extract the 'cloudfront-viewer-country-name' header. If the request fails
     * or the header is not present, it defaults to returning 'US'.
     *
     * @param {string} cdnUrl - The URL of the CDN to fetch the headers from.
     * @returns {Promise<string>} A promise that resolves to the country code as a string.
     * Defaults to 'US' in case of an error or missing header.
     */
    getCountryFromCDNResponse: async (cdnUrl) => {
      var _a;
      try {
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('CDN response timeout')), 1000);
        });

        const fetchPromise = fetch(cdnUrl, { method: 'HEAD' }).then((response) => {
          if (!response.ok) {
            logger.info(`Failed to fetch CDN headers: ${response.status}`);
          }
          return (_a = response.headers.get('cloudfront-viewer-country-name')) !== null &&
            _a !== void 0
            ? _a
            : 'N/A';
        });

        return await Promise.race([fetchPromise, timeoutPromise]);
      } catch (error) {
        console.error('Error fetching country from CDN headers:', error);
        return 'N/A';
      }
    },
    async loadScriptWithRetry(src, retries = 2, delay = 1000) {
      for (let attempt = 1; attempt <= retries; attempt++) {
        try {
          // Check if already loaded
          if (this.isScriptLoaded(src)) {
            logger.debug(`Script already loaded: ${src}`);
            return;
          }
          await this.loadScript(src);
          logger.debug(`Script loaded successfully on attempt ${attempt}: ${src}`);
          return;
        } catch (error) {
          if (attempt === retries) {
            logger.error(`Failed to load script after ${retries} attempts: ${src}`);
            throw error;
          }
          logger.warn(`Attempt ${attempt} failed, retrying in ${delay}ms: ${src}`);
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      }
    },
    /**
     * Gets external ad unit configuration
     * @param adUnitCode The ad unit ID
     * @returns The ad unit configuration
     */
    getExternalAdUnitConfig: (adUnitCode) => {
      return CONFIG.HEADER_BIDDING_EXTERNAL_ADS.find((adUnit) => adUnit.code === adUnitCode);
    },
    getInternalAdUnitConfigFromId: (adUnitId) => {
      return CONFIG.AD_UNITS[adUnitId];
    },
    getInternalAdUnitConfigFromCode: (adUnitCode) => {
      return Object.values(CONFIG.AD_UNITS).find((adUnit) => adUnit.code === adUnitCode);
    },
  };

  class StickyAd {
    constructor(adUnit, elementId) {
      this.adUnit = adUnit;
      this.elementId = elementId;
    }
    /**
     * Initializes sticky ads based on device type.
     */
    initializeStickyAds() {
      const deviceType = utils.getDeviceDetails().deviceType;
      logger.debug(`Initializing sticky ads for device: ${deviceType}`);
      if (this.adUnit.StickyDeviceType === deviceType && this.adUnit.StickyType) {
        logger.debug(
          `Creating sticky ad for: ${this.elementId}, Position: ${this.adUnit.StickyType}`
        );
        this.makeAdSticky();
        logger.debug(`Successfully initialized sticky ad: ${this.elementId}`);
      } else {
        logger.error('No sticky ads to initialize.');
      }
    }
    /**
     * Makes an existing ad div sticky.
     */
    makeAdSticky() {
      if (this.elementId == null) {
        logger.error('Ad unit ID not provided.');
        return;
      }
      const adDiv = document.getElementById(this.elementId);
      if (!adDiv) {
        logger.error(`Ad div with ID ${this.elementId} not found.`);
        return;
      }
      const stickyType = this.adUnit.StickyType;
      if (adDiv != null) {
        adDiv.style.position = 'fixed';
        adDiv.style.zIndex = '9999'; // Ensure it's on top
        switch (stickyType) {
          case 'top':
            adDiv.style.top = '0';
            adDiv.style.left = '50%';
            adDiv.style.transform = 'translateX(-50%)'; // Center horizontally
            break;
          case 'bottom':
            adDiv.style.bottom = '0';
            adDiv.style.left = '50%';
            adDiv.style.transform = 'translateX(-50%)'; // Center horizontally
            break;
          case 'left':
            adDiv.style.left = '0';
            adDiv.style.top = '50%';
            adDiv.style.transform = 'translateY(-50%)'; // Center vertically
            break;
          case 'right':
            adDiv.style.right = '0';
            adDiv.style.top = '50%';
            adDiv.style.transform = 'translateY(-50%)'; // Center vertically
            break;
          default:
            logger.warn(`Invalid sticky position: ${stickyType}`);
        }
      } else {
        logger.warn(`Ad div not found with ID: ${this.elementId}`);
      }
    }
  }

  class ObserverManager {
    constructor() {
      this.observers = new Map();
    }
    static getInstance() {
      if (!ObserverManager.instance) {
        ObserverManager.instance = new ObserverManager();
      }
      return ObserverManager.instance;
    }
    createIntersectionObserver(id, callback, options) {
      this.cleanup(id);
      const observer = new IntersectionObserver(callback, options);
      this.observers.set(id, observer);
      return observer;
    }
    cleanup(id) {
      var _a;
      if (id) {
        (_a = this.observers.get(id)) === null || _a === void 0 ? void 0 : _a.disconnect();
        this.observers.delete(id);
      } else {
        this.observers.forEach((observer) => observer.disconnect());
        this.observers.clear();
      }
    }
  }

  var _a$1;
  class VideoAd {
    /**
     * Creates a new VideoAd instance.
     * @param videoElementId The ID of the video element.
     * @param vastTagUrl The VAST tag URL for the video ad.
     */
    constructor(videoElementId, vastTagUrl) {
      this.isAdPlaying = false;
      this.isFloaterOpen = false;
      this.vastTagUrl = vastTagUrl;
      this.videoElementId = videoElementId;
      this.player = null;
      this.floaterPlayer = null;
      this.observerId = `video-${videoElementId}`;
    }
    /**
     * Initializes the video ad by creating the player and setting up IMA integration
     */
    init() {
      logger.debug('Initializing video ads...', this.videoElementId);
      if (window.videojs == null) {
        logger.error('Video.js is not loaded. Aborting video ad initialization.');
        return;
      }
      const videoElement = document.getElementById(this.videoElementId);
      if (videoElement == null) {
        logger.error('Video element not found');
        return;
      }
      // Initialize video.js player with IMA plugin
      this.player = window.videojs(this.videoElementId, {
        height: 360,
        width: 640,
        techOrder: ['html5'],
        sources: [
          {
            src: '//commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4',
            type: 'video/mp4',
          },
        ],
        controls: true,
        aspectRatio: '16:9',
        preload: 'auto',
        loop: false,
        poster:
          'https://a.storyblok.com/f/47007/1200x629/83e3f65a3f/rewarded-video-ads-blog-meta.png',
        playsinline: true,
        muted: CONFIG.STATUS.ADS.PROPERTY.VIDEO_MUTED,
        autoplay: CONFIG.STATUS.ADS.PROPERTY.VIDEO_AUTOPLAY,
      });
      // Initialize IMA plugin with enhanced configuration
      this.player.ima({
        id: this.videoElementId,
        adTagUrl: this.vastTagUrl,
        loadingSpinner: true,
      });
      // Initialize floater functionality if enabled
      if (CONFIG.STATUS.ADS.PROPERTY.FLOATER_VIDEO) {
        this.initializeFloater();
      }
      // Start ads when player is ready
      this.player.ready(() => {
        logger.debug('Video player ready, initializing IMA...');
        this.player.ima.initializeAdDisplayContainer();
      });
    }
    initializeFloater() {
      const observerManager = ObserverManager.getInstance();
      const observer = observerManager.createIntersectionObserver(
        this.observerId,
        (entries) => {
          if (entries[0].isIntersecting === false) {
            this.showFloater();
          } else {
            this.closeFloater();
          }
        },
        { threshold: 1.0, rootMargin: '200px' }
      );
      const videoElement = document.getElementById(this.videoElementId);
      if (videoElement) {
        observer.observe(videoElement);
      }
    }
    showFloater() {
      var _b;
      if (this.isFloaterOpen || document.getElementById(`${this.videoElementId}-floater`)) {
        return;
      }
      if (this.floaterPlayer == null) {
        this.createFloaterPlayer();
      }
      this.isFloaterOpen = true;
      (_b = this.floaterPlayer) === null || _b === void 0 ? void 0 : _b.play();
    }
    createFloaterPlayer() {
      if (document.getElementById(`${this.videoElementId}-floater-container`)) {
        return;
      }
      const floaterContainer = document.createElement('div');
      floaterContainer.id = `${this.videoElementId}-floater-container`;
      this.setupFloaterStyles(floaterContainer);
      const brandingBar = this.createBrandingBar();
      const floaterVideoElement = this.createFloaterVideoElement();
      floaterContainer.appendChild(brandingBar);
      floaterContainer.appendChild(floaterVideoElement);
      document.body.appendChild(floaterContainer);
      this.initializeFloaterPlayer(floaterVideoElement.id);
    }
    setupFloaterStyles(container) {
      Object.assign(container.style, {
        position: 'fixed',
        bottom: '20px',
        right: '20px',
        zIndex: '100001',
        backgroundColor: '#ffffff',
        border: '1px solid #ccc',
        borderRadius: '8px',
        boxShadow: '0 2px 8px rgba(0, 0, 0, 0.1)',
        overflow: 'hidden',
        width: '320px',
        display: 'flex',
        flexDirection: 'column',
      });
    }
    createBrandingBar() {
      const brandingBar = document.createElement('div');
      Object.assign(brandingBar.style, {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        padding: '2px 4px',
        backgroundColor: '#f9f9f9',
        borderBottom: '1px solid #eee',
      });
      const brandingText = document.createElement('span');
      brandingText.innerHTML = `Powered by <strong style="color:#007BFF;">UndrAds</strong>`;
      Object.assign(brandingText.style, {
        fontSize: '12px',
        color: '#888',
        fontFamily: 'Arial, sans-serif',
      });
      const closeButton = this.createCloseButton();
      brandingBar.appendChild(brandingText);
      brandingBar.appendChild(closeButton);
      return brandingBar;
    }
    createCloseButton() {
      const closeButton = document.createElement('button');
      closeButton.textContent = 'x';
      Object.assign(closeButton.style, {
        fontSize: '16px',
        background: 'none',
        border: 'none',
        color: '#888',
        cursor: 'pointer',
        padding: '5px',
        marginLeft: '10px',
      });
      closeButton.addEventListener('click', () => this.closeFloater());
      return closeButton;
    }
    createFloaterVideoElement() {
      const floaterVideoElement = document.createElement('video');
      floaterVideoElement.id = `${this.videoElementId}-floater`;
      floaterVideoElement.classList.add('video-js');
      Object.assign(floaterVideoElement.style, {
        width: '320px',
        height: '180px',
        borderRadius: '0',
        backgroundColor: 'black',
      });
      floaterVideoElement.controls = true;
      floaterVideoElement.preload = 'auto';
      floaterVideoElement.autoplay = CONFIG.STATUS.ADS.PROPERTY.FLOATER_VIDEO_AUTOPLAY;
      floaterVideoElement.muted = CONFIG.STATUS.ADS.PROPERTY.VIDEO_MUTED;
      const sourceElement = document.createElement('source');
      sourceElement.src = this.player.currentSrc();
      sourceElement.type = 'video/mp4';
      floaterVideoElement.appendChild(sourceElement);
      return floaterVideoElement;
    }
    initializeFloaterPlayer(floaterElementId) {
      this.floaterPlayer = window.videojs(floaterElementId, {
        width: 320,
        height: 180,
        controls: true,
        autoplay: CONFIG.STATUS.ADS.PROPERTY.FLOATER_VIDEO_AUTOPLAY,
        muted: CONFIG.STATUS.ADS.PROPERTY.VIDEO_MUTED,
      });
      this.floaterPlayer.ima({
        id: floaterElementId,
        adTagUrl: this.vastTagUrl,
        loadingSpinner: true,
      });
      this.floaterPlayer.ready(() => {
        logger.debug('Video player ready, initializing IMA...');
        this.floaterPlayer.ima.initializeAdDisplayContainer();
      });
      this.setupFloaterSyncEvents();
    }
    setupFloaterSyncEvents() {
      // Sync with main player
      this.player.on('timeupdate', () => {
        var _b, _c, _d;
        (_b = this.floaterPlayer) === null || _b === void 0
          ? void 0
          : _b.currentTime(this.player.currentTime());
        if (this.player.paused()) {
          (_c = this.floaterPlayer) === null || _c === void 0 ? void 0 : _c.pause();
        } else {
          (_d = this.floaterPlayer) === null || _d === void 0 ? void 0 : _d.play();
        }
      });
      // Sync controls
      this.floaterPlayer.on('pause', () => this.player.pause());
      this.floaterPlayer.on('play', () => this.player.play());
      this.floaterPlayer.on('ended', () => this.closeFloater());
      // Initialize IMA
      this.floaterPlayer.ima.initializeAdDisplayContainer();
      this.floaterPlayer.one('adsready', () => {});
    }
    closeFloater() {
      var _b;
      const floaterContainer = document.getElementById(`${this.videoElementId}-floater-container`);
      if (floaterContainer) {
        floaterContainer.remove();
      }
      (_b = this.floaterPlayer) === null || _b === void 0 ? void 0 : _b.dispose();
      this.floaterPlayer = null;
      this.isFloaterOpen = false;
    }
    /**
     * Clean up the video player and IMA resources
     */
    cleanup() {
      this.closeFloater();
      if (this.player != null) {
        try {
          if (this.player) {
            this.player.ima.destroy();
            this.player.dispose();
            this.player = null;
          }
          if (this.floaterPlayer) {
            this.floaterPlayer.dispose();
            this.floaterPlayer = null;
          }
          ObserverManager.getInstance().cleanup(this.observerId);
        } catch (error) {
          logger.error('Error during video player cleanup:', error);
        }
      }
    }
    /**
     * Creates a video element for video ads
     * @static
     */
    static createVideoElement() {
      const containers = document.querySelectorAll('ins.undrads.ua-video');
      for (const container of Array.from(containers)) {
        const videoId = container.getAttribute('data-ad-id');
        if (videoId == null) {
          logger.error('Video container missing data-ad-id attribute');
          return;
        }
        // Create video element
        const videoElement = document.createElement('video');
        videoElement.id = utils.getHashedId(videoId);
        videoElement.className = 'video-js vjs-default-skin vjs-big-play-centered';
        container.appendChild(videoElement);
        logger.debug('Created video element:', videoElement.id);
      }
    }
  }
  _a$1 = VideoAd;
  VideoAd.CONFIG = {
    ENDPOINTS: {
      STYLESHEET: {
        VIDEO_JS:
          'https://googleads.github.io/videojs-ima/node_modules/video.js/dist/video-js.min.css',
        VIDEO_JS_ADS:
          'https://googleads.github.io/videojs-ima/node_modules/videojs-contrib-ads/dist/videojs.ads.css',
        VIDEO_JS_IMA: 'https://googleads.github.io/videojs-ima/dist/videojs.ima.css',
      },
      SCRIPTS: {
        /**
         * Google IMA SDK script endpoint.
         * @see https://developers.google.com/interactive-media-ads/docs/sdks/html5/
         */
        IMA: 'https://imasdk.googleapis.com/js/sdkloader/ima3.js',
        VIDEO_JS: 'https://googleads.github.io/videojs-ima/node_modules/video.js/dist/video.min.js',
        VIDEO_JS_ADS:
          'https://googleads.github.io/videojs-ima/node_modules/videojs-contrib-ads/dist/videojs.ads.min.js',
        VIDEO_JS_IMA: 'https://googleads.github.io/videojs-ima/dist/videojs.ima.js',
        // VIDEO_JS: '/js/video-js.js',
        // VIDEO_JS_ADS: '/js/videojs.ads.js',
        // VIDEO_JS_IMA: '/js/videojs.ima.js',
      },
    },
  };
  /**
   * Loads all required scripts for UndrAds.
   * @returns {Promise<void>}
   */
  VideoAd.loadScripts = async () => {
    try {
      // Load IMA SDK first and ensure it's fully initialized
      await utils.loadScript(_a$1.CONFIG.ENDPOINTS.SCRIPTS.IMA);
      await new Promise((resolve, reject) => {
        const checkIma = () => {
          var _b;
          if (((_b = window.google) === null || _b === void 0 ? void 0 : _b.ima) != null) {
            try {
              // Create a temporary container in the DOM
              const testContainer = document.createElement('div');
              testContainer.style.display = 'none';
              document.body.appendChild(testContainer);
              // Test IMA SDK initialization
              const testDisplayContainer = new window.google.ima.AdDisplayContainer(testContainer);
              testDisplayContainer.initialize(); // Initialize to ensure SDK is working
              // Clean up
              document.body.removeChild(testContainer);
              logger.debug('IMA SDK loaded and initialized successfully');
              resolve();
            } catch (error) {
              logger.debug('IMA SDK not fully initialized yet:', error);
              setTimeout(checkIma, 50);
            }
          } else {
            logger.debug('Waiting for IMA SDK to load');
            setTimeout(checkIma, 50);
          }
        };
        // Set a timeout to avoid infinite waiting
        const timeoutId = setTimeout(() => {
          reject(new Error('IMA SDK initialization timeout after 2s'));
        }, 2000);
        checkIma();
        // Clear timeout if resolved successfully
        void Promise.resolve().then(() => clearTimeout(timeoutId));
      });
      // Now load Video.js and wait for it to be available globally
      await utils.loadScript(_a$1.CONFIG.ENDPOINTS.SCRIPTS.VIDEO_JS);
      await new Promise((resolve, reject) => {
        const timeoutId = setTimeout(() => {
          reject(new Error('Video.js initialization timeout after 2s'));
        }, 2000);
        const checkVideoJs = () => {
          if (window.videojs != null) {
            logger.debug('Video.js loaded successfully');
            clearTimeout(timeoutId);
            resolve();
          } else {
            setTimeout(checkVideoJs, 50);
          }
        };
        checkVideoJs();
      });
      // Load videojs-contrib-ads and wait for the plugin to be available
      await utils.loadScript(_a$1.CONFIG.ENDPOINTS.SCRIPTS.VIDEO_JS_ADS);
      await new Promise((resolve, reject) => {
        const timeoutId = setTimeout(() => {
          reject(new Error('videojs-contrib-ads initialization timeout after 2s'));
        }, 2000);
        const checkAdsPlugin = () => {
          var _b;
          if (
            ((_b = window.videojs) === null || _b === void 0 ? void 0 : _b.getPlugin('ads')) != null
          ) {
            logger.debug('videojs-contrib-ads loaded successfully');
            clearTimeout(timeoutId);
            resolve();
          } else {
            setTimeout(checkAdsPlugin, 50);
          }
        };
        checkAdsPlugin();
      });
      // Finally load IMA plugin
      await utils.loadScript(_a$1.CONFIG.ENDPOINTS.SCRIPTS.VIDEO_JS_IMA);
      await new Promise((resolve, reject) => {
        const timeoutId = setTimeout(() => {
          reject(new Error('videojs-ima initialization timeout after 2s'));
        }, 2000);
        const checkImaPlugin = () => {
          var _b;
          if (
            ((_b = window.videojs) === null || _b === void 0 ? void 0 : _b.getPlugin('ima')) != null
          ) {
            logger.debug('videojs-ima loaded successfully');
            clearTimeout(timeoutId);
            resolve();
          } else {
            setTimeout(checkImaPlugin, 50);
          }
        };
        checkImaPlugin();
      });
      logger.debug('All video scripts loaded and initialized successfully');
    } catch (error) {
      logger.error('Error loading video scripts:', error);
      throw error;
    }
  };
  /**
   * Loads all required stylesheets for UndrAds.
   * @returns {Promise<void>}
   */
  VideoAd.loadStyleSheets = async () => {
    try {
      await Promise.allSettled([
        utils.loadStyleSheet(_a$1.CONFIG.ENDPOINTS.STYLESHEET.VIDEO_JS),
        utils.loadStyleSheet(_a$1.CONFIG.ENDPOINTS.STYLESHEET.VIDEO_JS_ADS),
        utils.loadStyleSheet(_a$1.CONFIG.ENDPOINTS.STYLESHEET.VIDEO_JS_IMA),
      ]);
    } catch (error) {
      logger.error('Error loading all scripts:', error);
    }
  };

  /**
   * @fileoverview Initializes and manages interactions with the Google Tag (gtag.js).
   */
  class GPT {
    /**
     * Initializes and enables Google Publisher Tag (GPT) services.
     */
    static enableServices() {
      googletag.cmd.push(() => {
        googletag.pubads().disableInitialLoad();
      });
    }
    /**
     * Sets up GPT event listeners
     * @param onSlotLoadCallback Callback for slot load event
     * @param onSlotRenderEndedCallback Callback for slot render ended event
     */
    static setupEventListeners(onSlotLoadCallback, onSlotRenderEndedCallback) {
      googletag.cmd.push(() => {
        googletag.pubads().addEventListener('slotOnload', onSlotLoadCallback);
        googletag.pubads().addEventListener('slotRenderEnded', onSlotRenderEndedCallback);
      });
    }
    /**
     * Retrieves all GPT ad slots.
     * @returns An array of GPT ad slots.
     */
    static getAllSlots() {
      return googletag.pubads().getSlots();
    }
    /**
     * Retrieves a GPT ad slot by its ID.
     * @param adUnitId The ID of the ad unit.
     * @returns The GPT ad slot or undefined if not found.
     */
    static getSlotById(adUnitId) {
      const slots = googletag.pubads().getSlots();
      return slots.find((slot) => slot.getSlotElementId() === adUnitId);
    }
    /**
     * Retrieves a GPT ad slot by its code.
     * @param adUnitCode The code of the ad unit.
     * @returns The GPT ad slot or undefined if not found.
     */
    static getSlotByCode(adUnitCode) {
      const slots = googletag.pubads().getSlots();
      return slots.find((slot) => slot.getAdUnitPath() === adUnitCode);
    }
    /**
     * Retrieves the element ID associated with an ad unit code.
     * @param adUnitCode The code of the ad unit.
     * @returns The element ID or undefined if not found.
     */
    static getElementIdFromAdCode(adUnitCode) {
      var _a;
      const slot = this.getSlotByCode(adUnitCode);
      return (_a = slot === null || slot === void 0 ? void 0 : slot.getSlotElementId()) !== null &&
        _a !== void 0
        ? _a
        : '';
    }
    /**
     * Retrieves a GPT ad slot that includes the specified code.
     * @param adUnitCode - The code of the ad unit.
     * @returns - The GPT ad slot or undefined if not found.
     */
    static getSlotThatIncludesCode(adUnitCode) {
      const slots = googletag.pubads().getSlots();
      return slots.find((slot) => slot.getAdUnitPath().includes(adUnitCode));
    }
    /**
     * Retrieves a GPT ad slot that includes the specified element ID.
     * @param adUnitElementId - The ID of the ad unit.
     * @returns - The GPT ad slot or undefined if not found.
     */
    static getSlotThatIncludesId(adUnitElementId) {
      const slots = googletag.pubads().getSlots();
      return slots.find((slot) => {
        const elementId = slot.getSlotElementId();
        return elementId.includes(adUnitElementId) || elementId === adUnitElementId;
      });
    }
    /**
     * Checks if a slot includes a specific ad unit code.
     * @param slot The GPT ad slot.
     * @param adUnitCode The ad unit code to check.
     * @returns True if the slot includes the ad unit code, false otherwise.
     */
    static doesSlotIncludesCode(slot, adUnitCode) {
      var _a;
      return (_a =
        slot === null || slot === void 0 ? void 0 : slot.getAdUnitPath().includes(adUnitCode)) !==
        null && _a !== void 0
        ? _a
        : false;
    }
    /**
     * Retrieves the ad unit code associated with an element ID.
     * @param adUnitElementId The ID of the ad unit.
     * @returns The ad unit code or undefined if not found.
     */
    static getAdCodeFromElementId(adUnitElementId) {
      const slot = this.getSlotById(adUnitElementId);
      return slot === null || slot === void 0 ? void 0 : slot.getAdUnitPath();
    }
    /**
     * Checks if a slot is an interstitial ad
     * @param adUnitElementId The ID of the ad unit
     * @returns True if the slot is an interstitial ad, false otherwise
     */
    static isSlotInterstitial(adUnitElementId) {
      var _a;
      const slot = this.getSlotById(adUnitElementId);
      return (_a = slot === null || slot === void 0 ? void 0 : slot.getOutOfPage()) !== null &&
        _a !== void 0
        ? _a
        : false;
    }
    /**
     * Gets an existing GPT ad slot or creates a new one
     * @param adUnit The ad unit configuration
     * @param elementId The ID of the HTML element to load the ad into.
     * @returns The GPT ad slot or undefined if not found.
     */
    static getOrCreateSlot(adUnit, elementId) {
      var _a, _b, _c, _d;
      if (adUnit == null) {
        logger.error('Ad unit is missing');
        return;
      }
      if (elementId == null) {
        logger.error('Ad unit ID is missing');
        return;
      }
      const existingSlot = this.getSlotById(elementId);
      if (existingSlot) {
        logger.debug(`Reusing existing slot: ${elementId}`);
        return existingSlot;
      }
      logger.debug(`Defining new slot: ${elementId}`);
      const slot =
        (_d = googletag.defineSlot(
          adUnit.code,
          (_c =
            (_b = (_a = adUnit.mediaTypes) === null || _a === void 0 ? void 0 : _a.banner) ===
              null || _b === void 0
              ? void 0
              : _b.sizes) !== null && _c !== void 0
            ? _c
            : [],
          elementId
        )) === null || _d === void 0
          ? void 0
          : _d.addService(googletag.pubads());
      googletag.pubads().enableSingleRequest();
      googletag.enableServices();
      return slot;
    }
    /**
     * Displays and refreshes a Google ad slot
     * @param slot The GPT ad slot
     */
    static displayAd(slot) {
      googletag.display(slot);
      googletag.pubads().refresh([slot]);
    }

    static isSlotEmpty(slot) {
      const slotElementId = slot.getSlotElementId();
      const adContainer = document.getElementById(slotElementId);

      if (!adContainer) {
        console.warn(`Ad container with ID ${slotElementId} not found.`);
        return true;
      }

      const iframe = adContainer.querySelector('iframe');

      return iframe === null;
    }
  }

  class AmazonAds {
    /**
     * The Amazon publisher ID.
     * @type {string}
     */
    constructor(amazon_pub_id) {
      this.amazon_pub_id = amazon_pub_id;
    }
    /**
     * Initializes the Amazon advertising service.
     * @returns {void} A promise that resolves when Amazon is initialized.
     *
     * This function checks if the current environment is Amazon and, if so,
     * initializes the apstag library with the provided publisher ID and ad server.
     */
    initializeAmazon() {
      (function initializeAmazon(a9, a, p, s, t, A, g) {
        if (a[a9] != null) return;
        function queueCommand(c, r) {
          a[a9]._Q.push([c, r]);
        }
        a[a9] = {
          init: function (...args) {
            queueCommand('i', args);
          },
          fetchBids: function (...args) {
            queueCommand('f', args);
          },
          setDisplayBids: function () {},
          targetingKeys: function () {
            return [];
          },
          _Q: [],
        };
        A = p.createElement(s);
        A.async = true;
        A.src = t;
        g = p.getElementsByTagName(s)[0];
        g.parentNode.insertBefore(A, g);
      })('apstag', window, document, 'script', '//c.amazon-adsystem.com/aax2/apstag.js');
      window.apstag.init({ pubID: this.amazon_pub_id, adServer: 'googletag' });
    }
    /**
     * Fetches bids from Amazon for the specified ad units.
     *
     * This function checks if the Amazon advertising service is enabled. If it is not,
     * it proceeds with the provided callback immediately. If Amazon is enabled, it
     * fetches bids for the specified ad unit codes and sets the display bids using
     * the googletag command queue.
     *
     * @param {googletag.Slot} slot - The GPT slot for which to fetch bids.
     * @param {Array<AdUnitCode>} adUnitCodes - An array of ad unit codes for which to fetch bids.
     */
    fetchAmazonBids(slot, adUnitCodes) {
      if (!CONFIG.STATUS.ADS.AMAZON) {
        return;
      }
      const slots = adUnitCodes.map((adUnitCode) => {
        var _a, _b, _c, _d;
        logger.debug(`Fetching Amazon bids for ${adUnitCode}`);
        const elementId = slot.getSlotElementId();
        const isExternalAd = utils.isExternalAdUnit(adUnitCode);
        const isSlotInterstitial = GPT.isSlotInterstitial(elementId);
        if (isExternalAd && !isSlotInterstitial) {
          const adUnit = utils.getExternalAdUnitConfig(adUnitCode);
          return {
            slotID: elementId,
            slotName: adUnit === null || adUnit === void 0 ? void 0 : adUnit.code,
            sizes:
              (_b =
                (_a = adUnit === null || adUnit === void 0 ? void 0 : adUnit.mediaTypes) === null ||
                _a === void 0
                  ? void 0
                  : _a.banner) === null || _b === void 0
                ? void 0
                : _b.sizes,
          };
        }
        const adUnit = utils.getInternalAdUnitConfigFromCode(adUnitCode);
        if (adUnit == null) {
          logger.error(`Internal Ad Configuration for Amazon Ad: ${adUnitCode} not found!`);
          return;
        }
        if (elementId == null) {
          logger.error(`Element ID for Amazon Ad: ${adUnitCode} not found!`);
          return;
        }
        return {
          slotID: elementId,
          slotName: adUnit === null || adUnit === void 0 ? void 0 : adUnit.code,
          sizes:
            (_d =
              (_c = adUnit === null || adUnit === void 0 ? void 0 : adUnit.mediaTypes) === null ||
              _c === void 0
                ? void 0
                : _c.banner) === null || _d === void 0
              ? void 0
              : _d.sizes,
        };
      });
      window.apstag.fetchBids(
        {
          slots,
          timeout: CONFIG.TIMEOUTS.PREBID,
        },
        function (_bids) {
          googletag.cmd.push(function () {
            window.apstag.setDisplayBids();
            logger.debug('Amazon bids fetched and set.');
          });
        }
      );
    }
  }

  class MockHeaderBidding {
    /**
     * Initializes the mock header bidding setup.
     */
    static init() {
      logger.info('Setting up mock header bidding...');
      window.uapbjs.que.push(() => {
        window.uapbjs.setConfig({
          debugging: {
            enabled: isDevMode(),
            intercept: [
              {
                when: {
                  adUnitCode: '/1234/direct-ad-1',
                  bidder: 'appnexus',
                },
                then: {
                  cpm: 0.5,
                },
              },
              // Docked Ads
              ...Object.values(CONFIG.DOCKED_AD_UNITS.adUnits).map((adUnit) => ({
                when: {
                  adUnitCode: adUnit.code,
                  bidder: Object.values(CONFIG.BIDDERS)[
                    Math.floor(Math.random() * Object.values(CONFIG.BIDDERS).length)
                  ].bidder,
                },
                then: {
                  cpm: Math.random().toFixed(1),
                },
              })),
              // // Internal Ads
              ...Object.values(CONFIG.AD_UNITS).map((adUnit) => ({
                when: {
                  adUnitCode: adUnit.code,
                  bidder: Object.values(CONFIG.BIDDERS)[
                    Math.floor(Math.random() * Object.values(CONFIG.BIDDERS).length)
                  ].bidder,
                },
                then: {
                  cpm: Math.random().toFixed(1),
                },
              })),
              // // External Ads
              ...CONFIG.HEADER_BIDDING_EXTERNAL_ADS.map((adUnit) => ({
                when: {
                  adUnitCode: adUnit.code,
                  bidder: Object.values(CONFIG.BIDDERS)[
                    Math.floor(Math.random() * Object.values(CONFIG.BIDDERS).length)
                  ].bidder,
                },
                then: {
                  cpm: Math.random().toFixed(1),
                },
              })),
            ],
          },
        });
      });
    }
  }

  /**
   * @fileoverview Handles Prebid.js setup, configuration, and bid requests.
   */
  class PrebidManager {
    async initialise() {
      // Don't set consent Management if it's in dev mode
      if (isDevMode() === false && CONFIG.STATUS.ADS.PROPERTY.CONSENT_MANGEMENT) {
        logger.info('Setting up consent management...');
        this.setupConsentManagement();
      }
      // Initialize header bidding mockup in dev mode
      if (isDevMode()) {
        MockHeaderBidding.init();
      }
      await this.setIABConfig();
      this.setBidderSettings();
      this.setBidderSupplyChain();
      logger.info('PrebidManager: Initialization completed.');
    }
    setupConsentManagement() {
      try {
        window.uapbjs.que.push(() => {
          window.uapbjs.setConfig({
            debug: isDebugMode(),
            consentManagement: {
              gdpr: {
                cmpApi: 'iab',
                timeout: 10000,
                defaultGdprScope: true,
                allowAuctionWithoutConsent: false,
              },
              usp: {
                cmpApi: 'iab',
                timeout: 10000,
              },
            },
          });
        });
        logger.success('Consent management setup completed.');
      } catch (error) {
        logger.error('Consent management setup error:', error);
      }
    }
    /**
     * Fetches and sets the IAB configuration for Prebid.js.
     * It makes a request to an endpoint to retrieve IAB categories based on the publisher's URL.
     * @private
     */
    async setIABConfig() {
      try {
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('IAB fetch timeout')), 100);
        });

        const fetchPromise = fetch(CONFIG.ENDPOINTS.IAB, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            url: CONFIG.PUBLISHER_URL,
          }),
        });

        const response = await Promise.race([fetchPromise, timeoutPromise]).catch(() => {
          logger.info('IAB fetch timed out, using default value');
          return { ok: false };
        });

        let iabData = 631;
        if (response.ok) {
          iabData = await response.json();
        }

        logger.debug('IAB Config received:', iabData);
        window.uapbjs.que.push(() => {
          window.uapbjs.setConfig({
            debug: isDebugMode(),
            userSync: {
              userIds: [
                {
                  name: 'id5Id',
                  params: {
                    partner: 1767,
                    externalModuleUrl: 'https://cdn.id5-sync.com/api/1.0/id5PrebidModule.js',
                    pd: ' ',
                  },
                  storage: {
                    type: 'cookie',
                    name: 'id5id',
                    expires: 120,
                    refreshInSeconds: 7200,
                  },
                },
              ],
              debug: false,
              auctionDelay: 250,
              syncEnabled: true,
              syncDelay: 3000,
              filterSettings: {
                iframe: {
                  bidders: '*',
                  filter: 'include',
                },
              },
            },
            currency: {
              adServerCurrency: CONFIG.CURRENCY.DEFAULT,
              granularityMultiplier: CONFIG.CURRENCY.MULTIPLIER,
              conversionRateFile: 'https://cdn.jsdelivr.net/gh/prebid/currency-file@1/latest.json',
              defaultRates: { USD: { AED: CONFIG.CURRENCY.MULTIPLIER } },
            },
            ortb2: {
              site: {
                domain: CONFIG.PUBLISHER_DOMAIN,
                cat: iabData,
                page: CONFIG.PUBLISHER_DOMAIN,
              },
            },
            useBidCache: true,
            auctionOptions: { suppressStaleRender: true },
            publisherDomain: CONFIG.PUBLISHER_DOMAIN,
            timeout: CONFIG.TIMEOUTS.PREBID,
          });
        });
        logger.success('IAB config set successfully.');
      } catch (error) {
        logger.error('Error setting IAB config:', error);
      }
    }
    /**
     * Configures the bidder settings for Prebid.js.
     * This includes setting up ad server targeting for Prebid bids.
     * @private
     */
    setBidderSettings() {
      logger.info('Applying bidder settings...');
      window.uapbjs.bidderSettings = {
        standard: {
          storageAllowed: true,
          adserverTargeting: [
            {
              key: 'unad_hb_bidder',
              val: (bidResponse) => bidResponse.bidderCode,
            },
            {
              key: 'unad_hb_adid',
              val: (bidResponse) => bidResponse.adId,
            },
            {
              key: 'unad_hb_pb',
              val: (bidResponse) => bidResponse.pbDg,
            },
            {
              key: 'unad_hb_format',
              val: (bidResponse) => bidResponse.mediaType,
            },
          ],
        },
        rubicon: {
          bidCpmAdjustment: function (bidCpm, _bid) {
            return bidCpm * 0.8;
          },
        },
        mediafuse: {
          bidCpmAdjustment: function (bidCpm, _bid) {
            return bidCpm * 0.8;
          },
        },
      };
      logger.success('Bidder settings applied.');
    }
    setBidderSupplyChain() {
      try {
        logger.info('Setting bidder supply chain...');
        window.uapbjs.setBidderConfig({
          bidders: ['pubmatic'],
          config: {
            schain: {
              validation: 'relaxed',
              config: {
                ver: '1.0',
                complete: 1,
                nodes: [
                  {
                    asi: 'playstream.media',
                    sid: '5902',
                    hp: 1,
                  },
                ],
              },
            },
          },
        });
        logger.success('Bidder supply chain set.');
      } catch (error) {
        logger.error('Error setting bidder supply chain:', error);
      }
    }

    static addAdUnits(adUnits) {
      try {
        window.uapbjs.que.push(() => {
          const existingAdUnit = window.uapbjs.adUnits;

          // check if adUnit already exists
          for (const adUnit of adUnits) {
            if (existingAdUnit.some((unit) => unit.code === adUnit.code)) {
              window.uapbjs.removeAdUnit(adUnit.code);
            }
          }

          window.uapbjs.addAdUnits(adUnits);
        });
      } catch (error) {
        logger.error('Error adding ad units to Prebid:', error);
      }
    }

    /**
     * Requests bids from Prebid.js for the specified ad unit code.
     * @param adUnitCode The ad unit code for which to request bids.
     * @param country Optional country code for targeting.
     * @param bidsBackHandler A callback function to execute when bids are returned.
     */
    requestBids(adUnitCode, country = CONFIG.COUNTRY, bidsBackHandler) {
      try {
        window.uapbjs.que.push(() => {
          window.uapbjs.requestBids({
            timeout: CONFIG.TIMEOUTS.PREBID,
            adUnitCodes: [adUnitCode],
            bidsBackHandler: (bids) => {
              if (bids != null) {
                logger.debug(`Bids received for ad unit: ${adUnitCode}`, bids);
              }
              bidsBackHandler();
            },
            labels: [country],
          });
        });
      } catch (error) {
        logger.error('Error requesting bids:', error);
      }
    }
    /**
     * Requests bids for video ads and sends winning bid to IMA SDK.
     * @param adUnit The ad unit configuration.
     * @returns Promise<VastTagURL> - The VAST tag URL for the winning bid.
     */
    requestVideoHeaderBid(adUnit) {
      return new Promise((resolve) => {
        logger.debug(`Requesting video header bids for ad unit: ${adUnit.code}`);
        const videoAdUnit = {
          code: adUnit.code,
          mediaTypes: {
            video: {
              context: 'instream',
              playerSize: [[640, 480]],
              mimes: ['video/mp4', 'video/webm', 'application/javascript'],
              protocols: [2, 3, 5, 6, 7, 8],
              api: [2],
              maxduration: 30,
              linearity: 1,
              playbackmethod: [2],
              skip: 1,
              skipafter: 5,
            },
          },
          bids: [
            {
              bidder: 'appnexus',
              params: {
                placementId: 13232361,
                video: {
                  skippable: true,
                  playback_method: ['auto_play_sound_off'],
                },
              },
            },
            // Add more bidders as needed
            {
              bidder: 'pubmatic',
              params: {
                publisherId: '156276',
                adSlot: 'TEST_VIDEO',
                video: {
                  mimes: ['video/mp4', 'video/webm'],
                  skippable: true,
                  minduration: 5,
                  maxduration: 30,
                  startdelay: 0,
                  playbackmethod: [2],
                  api: [2],
                  protocols: [2, 3, 5, 6, 7, 8],
                  plcmt: 1,
                },
              },
            },
          ],
        };
        window.uapbjs.que.push(() => {
          window.uapbjs.addAdUnits([videoAdUnit]);
          window.uapbjs.setConfig({
            debug: isDebugMode(),
            cache: {
              url: 'https://prebid.adnxs.com/pbc/v1/cache',
            },
            enableSendAllBids: true,
          });
          window.uapbjs.requestBids({
            adUnitCodes: [adUnit.code],
            bidsBackHandler: (bids) => {
              var _a;
              logger.debug(`Bids received for video ad unit: ${adUnit.code}`, bids);
              const highestCpmBids = window.uapbjs.getHighestCpmBids(adUnit.code);
              if (highestCpmBids.length === 0) {
                logger.warn('No valid bids received');
                resolve('');
                return;
              }
              const winningBid = highestCpmBids[0];
              if (winningBid.vastUrl == null && winningBid.vastXml == null) {
                logger.warn('Winning bid has no VAST URL or XML');
                resolve('');
                return;
              }
              const vastUrl =
                (_a = winningBid.vastUrl) !== null && _a !== void 0
                  ? _a
                  : `https://prebid.adnxs.com/pbc/v1/cache?uuid=${winningBid.videoCacheKey}`;
              logger.debug(`Generated VAST URL: ${vastUrl}`);
              resolve(vastUrl);
            },
            timeout: CONFIG.TIMEOUTS.PREBID,
          });
        });
      });
    }
    /**
     * Sets ad server targeting for the given ad unit codes in Prebid.js.
     * @param adUnitCodes The ad unit codes to set targeting for.
     */
    setTargetingForGPTAsync(adUnitCodes) {
      window.uapbjs.que.push(() => {
        window.uapbjs.setTargetingForGPTAsync(adUnitCodes);
      });
    }
    /**
     * Enables analytics in Prebid.js.
     */
    sendAnalytics() {
      try {
        window.uapbjs.enableAnalytics({
          provider: 'undrads',
          options: {
            host: CONFIG.ENDPOINTS.ANALYTICS.HOST,
            pathname: CONFIG.ENDPOINTS.ANALYTICS.PATHNAME,
            country: CONFIG.COUNTRY,
          },
        });
      } catch (error) {
        logger.error('Analytics error:', error);
      }
    }
    /**
     * Renders an ad directly without GAM for the specified ad unit
     * @param adElement The HTML element to render the ad in
     * @param adUnitCode The ad unit code
     */
    renderDirectAd(adElement, adUnitCode) {
      try {
        window.uapbjs.que.push(() => {
          var _a;
          const winningBid = window.uapbjs.getHighestCpmBids(adUnitCode)[0];
          if ((winningBid === null || winningBid === void 0 ? void 0 : winningBid.adId) != null) {
            // Create iframe for the ad
            const iframe = document.createElement('iframe');
            iframe.scrolling = 'no';
            iframe.frameBorder = '0';
            iframe.marginHeight = '0';
            iframe.marginWidth = '0';
            iframe.name = `undrads_direct_ads_iframe_${adUnitCode}`;
            iframe.title = '3rd party ad content';
            iframe.setAttribute('aria-label', 'Advertisement');
            // Set sandbox attributes
            iframe.sandbox.add(
              'allow-forms',
              'allow-popups',
              'allow-popups-to-escape-sandbox',
              'allow-same-origin',
              'allow-scripts',
              'allow-top-navigation-by-user-activation'
            );
            // Set styles
            iframe.style.setProperty('border', '0');
            iframe.style.setProperty('margin', '0');
            iframe.style.setProperty('overflow', 'hidden');
            // Set size based on winning bid
            if (winningBid.width != null && winningBid.height != null) {
              iframe.width = winningBid.width.toString();
              iframe.height = winningBid.height.toString();
            }
            // Append iframe and render ad
            adElement.appendChild(iframe);
            const iframeDoc =
              (_a = iframe.contentWindow) === null || _a === void 0 ? void 0 : _a.document;
            if (iframeDoc) {
              window.uapbjs.renderAd(iframeDoc, winningBid.adId);
              // Add normalize CSS to iframe
              const normalizeCss = `/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */button,hr,input{overflow:visible}progress,sub,sup{vertical-align:baseline}[type=checkbox],[type=radio],legend{box-sizing:border-box;padding:0}html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}details,main{display:block}h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}a{background-color:transparent}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:ButtonText dotted 1px}fieldset{padding:.35em .75em .625em}legend{color:inherit;display:table;max-width:100%;white-space:normal}textarea{overflow:auto}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}[hidden],template{display:none}`;
              const iframeStyle = iframeDoc.createElement('style');
              iframeStyle.appendChild(iframeDoc.createTextNode(normalizeCss));
              iframeDoc.head.appendChild(iframeStyle);
            }
          } else {
            logger.warn(`No winning bid found for ad unit: ${adUnitCode}`);
          }
        });
      } catch (error) {
        logger.error('Error rendering direct ad:', error);
      }
    }
    /**
     * Request bids and render them directly without GAM
     * @param adElement The HTML element to render the ad in
     * @param adUnit The ad unit configuration
     * @param country Optional country code for targeting
     */
    requestBidsAndRenderDirectAd(adElement, adUnit, country = CONFIG.COUNTRY) {
      try {
        window.uapbjs.que.push(() => {
          window.uapbjs.addAdUnits([adUnit]);
          window.uapbjs.requestBids({
            timeout: CONFIG.TIMEOUTS.PREBID,
            adUnitCodes: [adUnit.code],
            bidsBackHandler: () => {
              this.setTargetingForGPTAsync([adUnit.code]);
              this.renderDirectAd(adElement, adUnit.code);
            },
            labels: [country],
          });
        });
      } catch (error) {
        logger.error('Error requesting and rendering direct ad:', error);
      }
    }
  }

  class HeaderBiddingManager {
    constructor() {
      this.displayAdCallback = null;
      this.prebidManager = new PrebidManager();
    }
    static getInstance() {
      if (HeaderBiddingManager.instance == null) {
        HeaderBiddingManager.instance = new HeaderBiddingManager();
      }
      return HeaderBiddingManager.instance;
    }
    setDisplayAdCallback(callback) {
      this.displayAdCallback = callback;
    }
    /**
     * Handles header bidding for display ads
     * @param adUnit The ad unit configuration
     * @param slot The GPT slot
     * @param displayCallback The callback to execute after bids are returned
     * @param isExternalAd Whether the ad is an external ad
     * @returns void
     */
    handleDisplayHeaderBidding(adUnit, slot, displayCallback, isExternalAd = false) {
      if (isExternalAd) {
        const adUnitPath = slot.getAdUnitPath();
        const externalAdUnitConfig = utils.getExternalAdUnitConfig(adUnitPath);
        if (externalAdUnitConfig) {
          this.processHeaderBidding(externalAdUnitConfig, slot, displayCallback);
        } else {
          logger.debug(`No header bidding config for external ad unit: ${adUnitPath}`);
          displayCallback(slot);
        }
        return;
      }
      if ((adUnit === null || adUnit === void 0 ? void 0 : adUnit.headerBidding) === 'on') {
        if ((adUnit === null || adUnit === void 0 ? void 0 : adUnit.prebidDirectServing) === 'on') {
          this.prebidManager.requestBidsAndRenderDirectAd(
            document.getElementById(slot.getSlotElementId()),
            adUnit
          );
          return;
        }
        this.processHeaderBidding(adUnit, slot, displayCallback);
      } else {
        displayCallback(slot);
      }
    }
    /**
     * Handles header bidding for video ads
     * @param adUnit The ad unit configuration
     * @returns VastTagURL - The VAST tag URL for the winning bid
     */
    async handleVideoHeaderBidding(adUnit) {
      var _a, _b;
      if (adUnit.headerBidding !== 'on') {
        return (_a = adUnit.vastTagURL) !== null && _a !== void 0 ? _a : '';
      }
      logger.debug('Loading Video Ad With Header Bidding');
      let bidVastUrl = await this.prebidManager.requestVideoHeaderBid(adUnit);
      if (bidVastUrl === '') {
        logger.debug('No winning bid for video ad');
        logger.debug('Falling back to default vast tag URL', adUnit.vastTagURL);
        bidVastUrl = (_b = adUnit.vastTagURL) !== null && _b !== void 0 ? _b : '';
      }
      return bidVastUrl;
    }
    /**
     * Process header bidding for all external ads on the page
     * @returns void
     */
    processHeaderBiddingOnExternalAds() {
      if (!this.displayAdCallback) {
        logger.error('Display ad callback not set');
        return;
      }
      const configuredExternalAdUnits = CONFIG.HEADER_BIDDING_EXTERNAL_ADS.map(
        (adUnit) => adUnit.code
      );
      if (configuredExternalAdUnits.length === 0) {
        logger.debug('No external ad units configured for header bidding');
        return;
      }
      logger.debug(
        `Processing header bidding for ${configuredExternalAdUnits.length} external ad units`,
        configuredExternalAdUnits
      );
      // Filter out ad units that includes the adCode in google ad frame
      const presentAdUnits = configuredExternalAdUnits.filter((adCode) => {
        const adSlot = GPT.getSlotByCode(adCode);
        return adSlot != null;
      });
      if (presentAdUnits.length === 0) {
        logger.debug('No configured external ad units found in DOM');
        return;
      }
      logger.debug(`Found ${presentAdUnits.length} external ad units in DOM`, presentAdUnits);
      // Process each present ad unit
      for (const adUnitCode of presentAdUnits) {
        const adUnit = utils.getExternalAdUnitConfig(adUnitCode);
        const adUnitId = GPT.getElementIdFromAdCode(adUnitCode);
        const slot = GPT.getOrCreateSlot(adUnit, adUnitId);
        if (slot) {
          this.displayAdCallback(adUnit, slot);
        }
      }
    }
    /**
     * Process header bidding for an ad unit
     * @param adUnit The ad unit configuration
     * @param slot The GPT slot
     * @param callback The callback to execute after bids are returned
     * @returns void
     */
    processHeaderBidding(adUnit, slot, callback) {
      googletag.cmd.push(() => {
        // window.uapbjs.addAdUnits([adUnit]);
        PrebidManager.addAdUnits([adUnit]);
        this.requestBids(slot, adUnit.code, callback);
      });
    }
    /**
     * Request bids from all configured bidders
     * @param slot The GPT slot
     * @param adUnitCode The ad unit code
     * @param callback The callback to execute after bids are returned
     * @param country Optional country code for targeting
     * @returns void
     */
    requestBids(slot, adUnitCode, callback, country = CONFIG.COUNTRY) {
      if (slot == null) {
        logger.error('Slot is missing for header bidding!');
        return;
      }
      if (CONFIG.STATUS.ADS.AMAZON) {
        const amazonAds = new AmazonAds(CONFIG.AMAZON_PUB_ID);
        amazonAds.fetchAmazonBids(slot, [adUnitCode]);
      }
      this.prebidManager.requestBids(adUnitCode, country, () => {
        this.prebidManager.setTargetingForGPTAsync([adUnitCode]);
        callback(slot);
      });
    }
  }

  /**
   * @fileoverview AdRefreshManager handles the automatic refresh of advertisement units on a webpage.
   *
   * Business Logic:
   * --------------
   * 1. Ad Refresh Cycle:
   * - Ads need to be refreshed periodically to maximize revenue and show new content
   * - Different ads (internal/external) have different refresh rules and intervals
   * - Ads should only refresh when they are visible to users (viewability requirement)
   *
   * 2. Refresh Types:
   * - Regular Refresh: Basic GPT refresh for standard ads
   * - Header Bidding Refresh: Advanced refresh including programmatic advertising partners
   * - External Ad Refresh: Special handling for third-party ad units
   *
   * 3. Refresh Conditions:
   * - Ad must be visible in viewport for at least 1 second
   * - Ad must not be currently in refresh process
   * - Ad must meet configuration requirements (refresh enabled, correct type, etc.)
   * - Interstitial ads are never refreshed
   *
   * Implementation Details:
   * ---------------------
   * - Uses Singleton pattern to ensure single instance across the application
   * - Implements IntersectionObserver for viewport tracking
   * - Maintains separate queues for ready-to-refresh and actively-refreshing ads
   * - Uses different timers for global refresh intervals and viewport visibility
   *
   * Refresh Flow:
   * 1. Ad loads initially -> setupRefresh() is called
   * 2. Global timer starts -> ad added to readyToRefreshQueue when interval hits
   * 3. Viewport observer tracks visibility -> starts viewport timer when visible
   * 4. After 1s visibility -> processRefresh() executes the refresh
   *
   * @example
   * // Initialize the manager
   * AdRefreshManager.init();
   *
   * // Setup refresh for an ad unit
   * const manager = AdRefreshManager.getInstance();
   * manager.setupRefresh('div-1');
   */
  class AdRefreshManager {
    constructor() {
      // Tracking refresh states for ad units
      /**
       * Stores timers for periodic refresh intervals for each ad unit.
       * Key: Ad unit element ID
       * Value: Timer ID from setInterval
       * Used to track and manage global refresh cycles independent of viewport visibility
       */
      this.refreshTimers = {};
      /**
       * Tracks ad units currently undergoing refresh process.
       * Prevents multiple simultaneous refresh attempts for the same ad unit.
       * Ads are added when refresh starts and removed when refresh completes or fails
       */
      this.activeRefreshQueue = new Set();
      /**
       * Stores ad units that have met their refresh interval and are waiting for viewport visibility.
       * Ads move from here to activeRefreshQueue when they become visible and start refreshing.
       * Acts as a staging area between refresh cycles
       */
      this.readyToRefreshQueue = new Set();
      /**
       * Tracks visibility timers for each ad unit.
       * Key: Ad unit element ID
       * Value: Timer ID from setTimeout
       * Ensures ads are visible for minimum duration before refresh (prevents rapid refresh on scroll)
       */
      this.viewportTimers = {};
      /**
       * Records timestamp of last successful refresh for each ad unit.
       * Key: Ad unit element ID
       * Value: Unix timestamp in milliseconds
       * Used for debugging and ensuring minimum time between refreshes
       */
      this.lastRefreshTimes = {};
      // Configuration constants
      this.VIEWPORT_VISIBILITY_THRESHOLD = 0.0; // 50% of ad must be visible
      this.VIEWPORT_VISIBILITY_DURATION = 1000; // Must be visible for 1 second
      this.viewportObserver = this.initViewportObserver();
    }
    static init() {
      if (AdRefreshManager.instance == null) {
        AdRefreshManager.instance = new AdRefreshManager();
      }
    }
    static getInstance() {
      if (AdRefreshManager.instance == null) {
        const errorMessage = 'AdRefreshManager not initialized. Call init() first.';
        logger.error(errorMessage);
        throw new Error(errorMessage);
      }
      return AdRefreshManager.instance;
    }
    /**
     * Initializes viewport tracking using IntersectionObserver.
     * Tracks when ads become visible/invisible in the viewport.
     * Critical for ensuring ads only refresh when viewable.
     * @returns IntersectionObserver
     */
    initViewportObserver() {
      return new IntersectionObserver(
        (entries) => {
          entries.forEach(this.handleIntersection.bind(this));
        },
        { threshold: this.VIEWPORT_VISIBILITY_THRESHOLD }
      );
    }
    /**
     * Handles intersection events for ad units.
     * Starts visibility timer when ad enters viewport and meets refresh criteria.
     * Clears timer when ad leaves viewport to prevent unnecessary refreshes.
     * @param entry - IntersectionObserverEntry
     */
    handleIntersection(entry) {
      const elementId = entry.target.id;
      if (elementId == null) {
        logger.warn('Intersection observer received entry without element ID');
        return;
      }
      if (entry.isIntersecting) {
        this.handleAdVisible(elementId);
      } else {
        this.handleAdHidden(elementId);
      }
    }
    handleAdVisible(elementId) {
      if (!this.isEligibleForRefresh(elementId)) {
        return;
      }
      this.startViewportTimer(elementId);
    }
    handleAdHidden(elementId) {
      this.clearViewportTimer(elementId);
    }
    isEligibleForRefresh(elementId) {
      return (
        this.readyToRefreshQueue.has(elementId) &&
        !this.activeRefreshQueue.has(elementId) &&
        !this.viewportTimers[elementId]
      );
    }
    /**
     * Starts the global refresh timer for an ad unit.
     * This timer determines how often an ad becomes eligible for refresh.
     * When timer triggers, ad is added to readyToRefreshQueue.
     *
     * @param elementId - The ad unit's DOM element ID
     * @param interval - Time between refresh eligibility in milliseconds
     */
    startGlobalTimer(elementId, interval) {
      if (interval <= 0) {
        logger.warn(`Invalid refresh interval for ${elementId}: ${interval}`);
        return;
      }
      this.clearRefreshTimer(elementId);
      this.refreshTimers[elementId] = window.setInterval(() => {
        try {
          if (this.canAddToReadyQueue(elementId)) {
            this.readyToRefreshQueue.add(elementId);
            logger.debug(`Added ${elementId} to ready-to-refresh queue`);
            const element = document.getElementById(elementId);
            if (element && utils.isInViewport(element)) {
              this.startViewportTimer(elementId);
            }
          }
        } catch (error) {
          logger.error(`Error in global timer for ${elementId}:`, error);
          this.cleanupAdUnit(elementId);
        }
      }, interval);
    }
    canAddToReadyQueue(elementId) {
      return (
        !this.readyToRefreshQueue.has(elementId) &&
        !this.activeRefreshQueue.has(elementId) &&
        !this.viewportTimers[elementId]
      );
    }
    /**
     * Core refresh processing logic.
     * Handles the actual refresh execution based on ad type and configuration.
     * Manages state transitions between ready and active queues.
     *
     * Flow:
     * 1. Validate ad slot and refresh strategy
     * 2. Move ad to active queue
     * 3. Execute appropriate refresh type (regular/header bidding)
     * 4. Update tracking and cleanup
     * @param elementId - The ad unit's DOM element ID
     */
    async processRefresh(elementId) {
      const slot = GPT.getSlotById(elementId);
      if (slot == null) {
        this.cleanupAdUnit(elementId);
        return;
      }
      if (!this.validateSlotForRefresh(slot, elementId)) {
        return;
      }
      const strategy = this.determineRefreshStrategy(slot);
      if (!strategy.shouldRefresh) {
        this.cleanupAdUnit(elementId);
        return;
      }
      if (this.activeRefreshQueue.has(elementId)) {
        return;
      }
      try {
        await this.executeRefreshProcess(slot, strategy, elementId);
      } catch (error) {
        logger.error(`Error refreshing ad ${elementId}:`, error);
        this.cleanupAdUnit(elementId);
      }
    }
    validateSlotForRefresh(slot, elementId) {
      if (!slot || slot.getAdUnitPath() === '') {
        this.cleanupAdUnit(elementId);
        return false;
      }
      return true;
    }
    async executeRefreshProcess(slot, strategy, elementId) {
      this.activeRefreshQueue.add(elementId);
      this.readyToRefreshQueue.delete(elementId);
      this.clearViewportTimer(elementId);
      const adUnitPath = slot.getAdUnitPath();
      const isExternalAd = utils.isExternalAdUnit(adUnitPath);
      const adUnit = this.getAdUnitConfig(adUnitPath, isExternalAd);
      if (strategy.useHeaderBidding && adUnit) {
        await this.refreshWithHeaderBidding(slot, adUnit, isExternalAd);
      } else {
        await this.executeRefresh(elementId);
      }
      this.lastRefreshTimes[elementId] = Date.now();
      this.activeRefreshQueue.delete(elementId);
    }
    getAdUnitConfig(adUnitPath, isExternalAd) {
      return isExternalAd
        ? utils.getExternalAdUnitConfig(adUnitPath)
        : utils.getInternalAdUnitConfigFromCode(adUnitPath);
    }
    async executeRefresh(elementId) {
      const slot = GPT.getSlotById(elementId);
      if (!slot) {
        logger.warn(`No slot found for executing refresh on: ${elementId}`);
        return;
      }
      if (!this.validateSlotForRefresh(slot, elementId)) {
        return;
      }
      const responseInfo = slot.getResponseInformation();
      if (
        (responseInfo === null || responseInfo === void 0 ? void 0 : responseInfo.lineItemId) !=
          null &&
        CONFIG.INCLUDED_LINE_ITEM_ID.includes(responseInfo.lineItemId.toString())
      ) {
        return;
      }
      return new Promise((resolve) => {
        googletag.cmd.push(() => {
          googletag.pubads().refresh([slot]);
          logger.debug(`Refreshed ad: ${elementId}`);
          resolve();
        });
      });
    }
    /**
     * Public method to set up refresh for an ad unit.
     * Called when ad initially loads or needs refresh configuration.
     * Determines refresh strategy and sets up necessary timers and observers.
     *
     * @param elementId - The ad unit's DOM element ID
     */
    setupRefresh(elementId) {
      try {
        const slot = GPT.getSlotById(elementId);
        if (slot == null) {
          logger.warn(`No slot found for ${elementId}`);
          return;
        }
        const strategy = this.determineRefreshStrategy(slot);
        if (!strategy.shouldRefresh) {
          return;
        }
        this.startGlobalTimer(elementId, strategy.refreshInterval);
        const element = document.getElementById(elementId);
        if (element != null && this.viewportObserver != null) {
          this.viewportObserver.observe(element);
          logger.debug(
            `Setup refresh for ${elementId} with interval ${strategy.refreshInterval}ms`
          );
        }
      } catch (error) {
        logger.error(`Error setting up refresh for ${elementId}:`, error);
      }
    }
    cleanupAdUnit(elementId) {
      this.readyToRefreshQueue.delete(elementId);
      this.activeRefreshQueue.delete(elementId);
      this.clearViewportTimer(elementId);
      this.clearRefreshTimer(elementId);
    }
    cleanup() {
      try {
        for (const elementId of Object.keys(this.refreshTimers)) {
          this.cleanupAdUnit(elementId);
        }
        if (this.viewportObserver != null) {
          this.viewportObserver.disconnect();
        }
        this.readyToRefreshQueue.clear();
        this.activeRefreshQueue.clear();
        for (const key of Object.keys(this.lastRefreshTimes)) {
          delete this.lastRefreshTimes[key];
        }
      } catch (error) {
        logger.error('Error during cleanup:', error);
      }
    }
    clearViewportTimer(elementId) {
      const timer = this.viewportTimers[elementId];
      if (typeof timer === 'number') {
        window.clearTimeout(timer);
        delete this.viewportTimers[elementId];
      }
    }
    clearRefreshTimer(elementId) {
      const timer = this.refreshTimers[elementId];
      if (typeof timer === 'number') {
        window.clearInterval(timer);
        delete this.refreshTimers[elementId];
      }
    }
    /**
     * Determines the refresh strategy for an ad slot.
     * Considers:
     * - Ad type (internal/external)
     * - Configuration settings
     * - Header bidding requirements
     * - Refresh intervals
     *
     * @param slot
     * @returns RefreshStrategy object with refresh parameters
     */
    determineRefreshStrategy(slot) {
      var _a, _b, _c, _d;
      const adUnitPath = slot.getAdUnitPath();
      const isExternalAd = utils.isExternalAdUnit(adUnitPath);
      const elementId = slot.getSlotElementId();
      // Get ad unit configuration
      let adUnit;
      if (isExternalAd) {
        adUnit = utils.getExternalAdUnitConfig(adUnitPath);
      } else {
        adUnit = utils.getInternalAdUnitConfigFromCode(adUnitPath);
      }
      // Default strategy
      const defaultStrategy = {
        shouldRefresh: false,
        useHeaderBidding: false,
        refreshInterval: CONFIG.TIMEOUTS.HEADER_BIDDING_REFRESH_EXTERNAL_ADS,
      };
      // Early return if no ad unit configuration
      if (!adUnit) {
        logger.debug(`No ad unit configuration found for ${adUnitPath}`);
        return defaultStrategy;
      }
      // Check if it's an interstitial (which shouldn't refresh)
      if (GPT.isSlotInterstitial(elementId)) {
        logger.debug(`Interstitial ad unit: ${elementId} has refresh disabled`);
        return defaultStrategy;
      }
      // Determine refresh strategy for internal ads
      if (!isExternalAd) {
        const shouldRefresh =
          CONFIG.STATUS.ADS.PROPERTY.REFRESH &&
          ((_a = adUnit.refresh) === null || _a === void 0 ? void 0 : _a.status) === 'on';
        const refreshInterval = (
          (_b = adUnit === null || adUnit === void 0 ? void 0 : adUnit.refresh) === null ||
          _b === void 0
            ? void 0
            : _b.time
        )
          ? adUnit.refresh.time * 1000
          : CONFIG.TIMEOUTS.REFRESH;
        return {
          shouldRefresh,
          useHeaderBidding: shouldRefresh && adUnit.headerBidding === 'on',
          refreshInterval,
        };
      }
      // Determine refresh strategy for external ads
      const shouldRefreshExternal =
        CONFIG.STATUS.ADS.PROPERTY.REFRESH_EXTERNAL_ADS &&
        CONFIG.REFRESH_EXTERNAL_ADS.includes(adUnitPath);
      const shouldRefreshWithHeaderBidding =
        CONFIG.STATUS.ADS.PROPERTY.HEADER_BIDDING_EXTERNAL_ADS &&
        ((_c = adUnit.refresh) === null || _c === void 0 ? void 0 : _c.status) === 'on' &&
        adUnit.headerBidding === 'on';
      const refreshInterval = ((_d = adUnit.refresh) === null || _d === void 0 ? void 0 : _d.time)
        ? adUnit.refresh.time * 1000
        : CONFIG.TIMEOUTS.REFRESH_EXTERNAL_ADS;
      return {
        refreshInterval,
        shouldRefresh: shouldRefreshExternal || shouldRefreshWithHeaderBidding,
        useHeaderBidding: shouldRefreshWithHeaderBidding,
      };
    }
    refreshWithHeaderBidding(slot, adUnit, isExternalAd) {
      const adUnitPath = slot.getAdUnitPath();
      logger.debug(`Refreshing ad with header bidding: ${adUnitPath}`);
      const headerBiddingManager = HeaderBiddingManager.getInstance();
      headerBiddingManager.handleDisplayHeaderBidding(
        adUnit,
        slot,
        (slot) => {
          void this.executeRefresh(slot.getSlotElementId());
        },
        isExternalAd
      );
    }
    /**
     * Starts a timer to track how long an ad has been visible in the viewport.
     * Once the visibility duration threshold is met, triggers the refresh process.
     *
     * @param elementId - The ad unit's DOM element ID
     */
    startViewportTimer(elementId) {
      // Clear any existing viewport timer for this ad
      this.clearViewportTimer(elementId);
      // Start new viewport visibility timer
      this.viewportTimers[elementId] = window.setTimeout(() => {
        try {
          void this.processRefresh(elementId);
        } catch (error) {
          logger.error(`Error in viewport timer for ${elementId}:`, error);
          this.cleanupAdUnit(elementId);
        }
      }, this.VIEWPORT_VISIBILITY_DURATION);
      logger.debug(
        `Started viewport timer for ${elementId} with duration ${this.VIEWPORT_VISIBILITY_DURATION}ms`
      );
    }
  }

  /**
   * @fileoverview Manages ad units, loading, and refresh behavior.
   */
  class AdUnitManager {
    constructor() {
      this.lazyAdObservers = new Map();
      AdRefreshManager.init();
      this.refreshManager = AdRefreshManager.getInstance();
      this.headerBiddingManager = HeaderBiddingManager.getInstance();
      this.replacementTimeout = null;
      // Set the callback for header bidding manager
      this.headerBiddingManager.setDisplayAdCallback((adUnit, slot) => {
        this.showAd(adUnit, slot, true);
      });
      this.observerId = null;
    }
    static getInstance() {
      if (AdUnitManager.instance == null) {
        AdUnitManager.instance = new AdUnitManager();
      }
      return AdUnitManager.instance;
    }
    init() {
      logger.info('Initializing AdUnitManager...');
      GPT.setupEventListeners(
        (event) => this.handleSlotOnload(event),
        (event) => this.handleSlotRenderEnded(event)
      );
    }
    /**
     * Parses the ad unit information from the element ID.
     * @param elementId The ID of the ad unit element.
     * @returns An object containing the parsed ad unit information.
     */
    parseAdUnitInfo(elementId) {
      const adUnitCode = GPT.getAdCodeFromElementId(elementId);
      const isInternalAdUnit = utils.isInternalAdUnit(adUnitCode);
      const adUnitId = isInternalAdUnit ? elementId.split('_ins_')[0] : elementId;
      const adUnitData = isInternalAdUnit
        ? CONFIG.AD_UNITS[adUnitId]
        : CONFIG.HEADER_BIDDING_EXTERNAL_ADS.find((adUnit) => adUnit.code === adUnitCode);
      logger.debug(
        `Parsed AdUnitInfo: isInternalAdUnit: ${isInternalAdUnit}, adUnitId: ${adUnitId}`
      );
      logger.debug(`Parsed AdUnitData:`, adUnitData);
      return { isInternalAdUnit, adUnitId, adUnitCode, adUnitData };
    }
    logSlotInfo(slot, adUnitInfo) {
      const elementId = slot.getSlotElementId();
      const adUnitPath = slot.getAdUnitPath();
      const unitType = adUnitInfo.isInternalAdUnit ? 'Internal Ad' : 'External Ad';
      logger.debug(
        `Slot loaded: [${unitType}] element id: ${elementId}, Ad Unit Code: ${adUnitPath}`
      );
    }
    /**
     * Handles the 'slotOnload' event for a GPT slot.
     * @param event The slotOnload event.
     */
    handleSlotOnload(event) {
      const slot = event.slot;
      const elementId = slot.getSlotElementId();
      const adUnitInfo = this.parseAdUnitInfo(elementId);
      this.logSlotInfo(slot, adUnitInfo);
      // AdRefreshManager handles all refresh logic
      if (CONFIG.COUNTRY === 'United States') {
        this.refreshManager.setupRefresh(elementId);
      }
    }
    handleSlotRenderEnded(event) {
      const slot = event.slot;
      const elementId = slot.getSlotElementId();
      const adUnitCode = GPT.getAdCodeFromElementId(elementId);
      const isExternalAd = utils.isExternalAdUnit(adUnitCode);
      if (event.isEmpty && CONFIG.STATUS.ADS.PROPERTY.EMPTY_EXTERNAL_ADS_REPLACE) {
        logger.debug(
          `Slot ${elementId} is empty for ${isExternalAd ? 'External' : 'Internal'} Ad.`
        );
        if (GPT.isSlotInterstitial(elementId)) {
          logger.debug(`Interstitial ad is empty. Skipping...`);
          return;
        }
        if (isExternalAd) {
          // Replace the external ad with internal ad
          logger.debug(`External ad (Empty): ${elementId}`);
          if (CONFIG.STATUS.ADS.PROPERTY.REPLACE_EXTERNAL_ADS) {
            setTimeout(() => {
              this.replaceAllExternalAdSlotsWithSameAdCode(adUnitCode);
            }, 3000);
            return;
          }
        } else {
          // Refresh the empty ad slot for internal ad
          logger.debug(`Internal ad (Empty): ${elementId}`);
          this.refreshManager.setupRefresh(elementId);
        }
      }
    }
    /**
     * Retrieves the GPT slot object associated with the given ad unit ID.
     * @param adUnitId The ID of the ad unit.
     * @returns The GPT slot object associated with the ad unit ID, or undefined if not found.
     */
    getSlotById(adUnitId) {
      return GPT.getSlotById(adUnitId);
    }
    /**
     * Loads a video ad based on the provided ad unit configuration and element ID.
     * @param adUnit The ad unit configuration object.
     * @param elementId The ID of the HTML element to load the ad into.
     */
    async loadVideoAd(adUnit, elementId) {
      const vastUrl = await this.headerBiddingManager.handleVideoHeaderBidding(adUnit);
      const videoAd = new VideoAd(elementId, vastUrl);
      await videoAd.init();
    }
    /**
     * Public function to trigger the loading of an ad unit.
     * @param element The HTML element to load the ad into.
     * @param adId The ID of the ad unit to load.
     * @param adType The type of ad unit to load.
     */
    triggerAd(element, adId, adType) {
      const adUnit = CONFIG.AD_UNITS[adId];
      logger.debug('Triggering ad element:', element);
      if (adUnit != null && element != null) {
        logger.debug(`Loading ad: ${adId}, Type: ${adType}`);
        this.loadAd(adUnit, element.id, adType);
      } else {
        logger.error(`Ad unit or element with ID ${adId} not found.`);
      }
    }
    /**
     * Loads an ad unit based on its configuration.
     * @param adUnit The ad unit configuration object.
     * @param elementId The ID of the HTML element to load the ad into.
     * @param adType The type of ad unit to load.
     */
    loadAd(adUnit, elementId, adType) {
      if (elementId == null) {
        logger.error('Ad unit ID is missing');
        return;
      }
      switch (adType) {
        // For loading sticky ads
        case AdType.STICKY: {
          const stickyAd = new StickyAd(adUnit, elementId);
          stickyAd.initializeStickyAds();
          break;
        }
        // For loading interstitial ads
        case AdType.INTERSTITIAL: {
          const interstitialAd = new InterstitialAd(adUnit, elementId);
          const slot = interstitialAd.init();
          this.showAd(adUnit, slot);
          return;
        }
        // For loading structural ads
        case AdType.STRUCTURAL:
          logger.debug(`Loading structural ad: ${elementId}`);
          break;
        // For loading Chained Ads
        case AdType.DOCKED: {
          logger.debug(`Loading docked ad: ${elementId}`);
          break;
        }
        // For loading Video Ads
        case AdType.VIDEO:
          void this.loadVideoAd(adUnit, elementId);
          return;
        default:
          logger.error(`Unknown ad type: ${adType}`);
          return;
      }
      // Observe the ad container for visibility
      if (CONFIG.STATUS.ADS.PROPERTY.LAZY_LOADING || adUnit.lazyLoading === 'on') {
        this.observeAdContainer(adUnit, elementId);
      } else {
        const slot = GPT.getOrCreateSlot(adUnit, elementId);
        this.showAd(adUnit, slot);
      }
    }
    /**
     * Observes an ad container for visibility and loads the ad when it enters the viewport.
     * @param adUnit The ad unit configuration.
     * @param elementId The ID of the HTML element to observe.
     */
    observeAdContainer(adUnit, elementId) {
      // Clear existing observer if any
      if (this.lazyAdObservers.has(elementId)) {
        const existingObserver = this.lazyAdObservers.get(elementId);
        existingObserver === null || existingObserver === void 0
          ? void 0
          : existingObserver.disconnect();
        this.lazyAdObservers.delete(elementId);
      }
      const adContainer = document.getElementById(elementId);
      if (!adContainer) {
        logger.error(`Ad container not found for ID: ${elementId}`);
        return;
      }
      const observerManager = ObserverManager.getInstance();
      this.observerId = `ad-${elementId}`;
      const observer = observerManager.createIntersectionObserver(
        this.observerId,
        (entries) => {
          for (const entry of entries) {
            if (entry.isIntersecting) {
              const slot = GPT.getOrCreateSlot(adUnit, elementId);
              if (slot) {
                this.showAd(adUnit, slot);
              }
              observer.unobserve(adContainer);
              observerManager.cleanup(this.observerId);
              this.lazyAdObservers.delete(elementId);
            }
          }
        },
        {
          rootMargin: '200px',
          threshold: 0.1,
        }
      );
      observer.observe(adContainer);
      this.lazyAdObservers.set(elementId, observer);
    }
    showAd(adUnit, slot, isExternalAd = false) {
      if (!slot) return;
      this.headerBiddingManager.handleDisplayHeaderBidding(
        adUnit,
        slot,
        (slot) => this.displayGoogleAd(slot),
        isExternalAd
      );
    }
    /**
     * Loads an external ad unit based on its element ID.
     * @param elementId The ID of the HTML Ad element to load the ad into.
     */
    showExternalAd(elementId) {
      const slot = GPT.getOrCreateSlot(undefined, elementId);
      if (slot) {
        logger.debug(`Loading external ad: ${elementId}`);
        this.showAd(undefined, slot, true);
      }
    }
    /**
     * Displays a Google ad using the provided slot.
     * @param slot The GPT slot object to display the ad in.
     */
    displayGoogleAd(slot) {
      GPT.displayAd(slot);
    }
    /**
     * Initializes the replacement process with a delay
     */
    initReplacement() {
      var _a;
      const delay =
        (_a = CONFIG.TIMEOUTS.REPLACE_EXTERNAL_ADS) !== null && _a !== void 0 ? _a : 30000; // Default to 30 seconds if not configured
      logger.debug(`Scheduling external ad replacement in ${delay}ms`);
      this.replaceExternalAds(delay);
    }
    /**
     * Replaces external ad units with UndrAds units based on mapping configuration
     */
    replaceExternalAds(delay) {
      var _a, _b;
      try {
        // Get all slots
        const slots = GPT.getAllSlots();
        for (const slot of slots) {
          const isSlotEmpty = GPT.isSlotEmpty(slot);
          const adUnitPath = slot.getAdUnitPath();
          let spliceNumber = 2;
          if (CONFIG.PUBLISHER_DOMAIN === 'herzindagi.com') {
            spliceNumber = 3;
          }
          const externalAdUnitCode = adUnitPath.split('/').splice(spliceNumber).join('/');

          if (externalAdUnitCode == null) {
            logger.warn(`Unable to find external ad unit code for replacement. Skipping...`);
            continue;
          }

          if (!GPT.doesSlotIncludesCode(slot, externalAdUnitCode)) {
            logger.debug(`External Ad Unit Code not did not match in slot: ${externalAdUnitCode}`);
            continue;
          }

          const internalAdUnitId = CONFIG.REPLACE_EXTERNAL_ADS.get(externalAdUnitCode);

          if (internalAdUnitId == null) {
            logger.warn(`No replacement ad unit found for ${externalAdUnitCode}. Skipping...`);
            continue;
          }

          if (isSlotEmpty) {
            const emptyExternalAdReplacementDelay = 3000;
            this.replacementTimeout = window.setTimeout(() => {
              this.replaceAdSlot(slot, internalAdUnitId);
            }, emptyExternalAdReplacementDelay);
            return;
          }

          const lineItemId =
            (_b =
              (_a = slot.getResponseInformation()) === null || _a === void 0
                ? void 0
                : _a.lineItemId) === null || _b === void 0
              ? void 0
              : _b.toString();
          if (
            lineItemId == null ||
            !CONFIG.INCLUDED_LINE_ITEM_ID.includes(lineItemId) ||
            CONFIG.EXCLUDED_LINE_ITEM_ID.includes(lineItemId)
          ) {
            logger.info(`Condition failed for replacement of external ad: ${externalAdUnitCode}, 
                  LineItemID: ${lineItemId}, 
                  Included: ${CONFIG.INCLUDED_LINE_ITEM_ID.includes(lineItemId)}, 
                  Excluded: ${CONFIG.EXCLUDED_LINE_ITEM_ID.includes(lineItemId)}`);
            continue;
          }

          // Only replace those external ads which are included in the Line Item ID list
          // and not in the excluded list
          logger.debug(
            `Replacing external ad: ${externalAdUnitCode}, LineItemID: ${lineItemId} with ${internalAdUnitId}; (Chill...)`
          );
          this.replacementTimeout = window.setTimeout(() => {
            this.replaceAdSlot(slot, internalAdUnitId);
          }, delay);
        }
      } catch (error) {
        logger.error('Error replacing external ads:', error);
      } finally {
        this.replacementTimeout = null;
      }
    }
    /**
     * Replaces all external ad slots with same ad code
     * @param externalAdUnitCode - The external ad unit code to replace
     * @returns void
     */
    replaceAllExternalAdSlotsWithSameAdCode(externalAdUnitCode) {
      const slots = GPT.getAllSlots();
      const externalAdSlots = slots.filter((slot) =>
        GPT.doesSlotIncludesCode(slot, externalAdUnitCode)
      );
      const internalAdUnitId = CONFIG.REPLACE_EXTERNAL_ADS.get(externalAdUnitCode);
      if (internalAdUnitId == null) {
        logger.debug(`No replacement ad unit found for ${externalAdUnitCode}`);
        return;
      }
      for (const slot of externalAdSlots) {
        logger.debug(`Replacing external ad: ${externalAdUnitCode}`);
        this.replaceAdSlot(slot, internalAdUnitId);
      }
    }
    /**
     * Replaces a single external ad slot with UndrAds unit
     * @param slot - The external ad slot to replace
     * @param internalAdUnitId - The internal ad unit ID to replace with
     */
    replaceAdSlot(slot, internalAdUnitId) {
      var _a;
      try {
        const adUnitCode = slot === null || slot === void 0 ? void 0 : slot.getAdUnitPath();
        // Create new internal ad element
        const internalAdElement = utils.createAdElement(internalAdUnitId);
        const externalElementId = GPT.getElementIdFromAdCode(adUnitCode);
        // Find the HTMLElement if the externalElementId is included in id or data-ad-id
        const externalAdElement = document.querySelector(
          `[id*="${externalElementId}"], [data-ad-id*="${externalElementId}"]`
        );
        if (externalAdElement == null) {
          logger.error(`No external ad element found for ${externalElementId}`);
          return;
        }
        // Replace the external slot with UndrAds element
        (_a = externalAdElement.parentNode) === null || _a === void 0
          ? void 0
          : _a.replaceChild(internalAdElement, externalAdElement);
        // Load the ad using AdUnitManager
        const adUnit = CONFIG.AD_UNITS[internalAdUnitId];
        if (adUnit == null) {
          logger.warn(`Internal Ad Configuration for ${internalAdUnitId} not found!`);
          logger.info(
            `The ${externalAdElement.getAttribute(
              'id'
            )} ad was supposed to be replaced with ${internalAdUnitId} but it was not found.`
          );
          return;
        }
        // Delete the slots
        googletag.cmd.push(() => {
          googletag.destroySlots([slot]);
        });
        // Load the internal Ad
        this.loadAd(adUnit, internalAdElement.id, AdType.STRUCTURAL);
        logger.debug(
          `Successfully Replaced external ad ${externalAdElement.getAttribute(
            'id'
          )} with internal ad unit ${internalAdUnitId}`
        );
      } catch (error) {
        logger.error(`Error replacing ad slot: ${error}`);
      }
    }
    cleanup() {
      // Clear all observers
      ObserverManager.getInstance().cleanup();
      this.lazyAdObservers.clear();
      // Clear refresh manager
      this.refreshManager.cleanup();
      // Clear replacement timeout
      if (this.replacementTimeout != null) {
        window.clearTimeout(this.replacementTimeout);
        this.replacementTimeout = null;
      }
    }
  }

  class DockedAd {
    constructor(dockedConfig) {
      this.container = null;
      this.adContainers = [];
      this.adElementIds = [];
      this.adUnits = dockedConfig.adUnits;
      // If chained mode is enabled, do nothing
      if (dockedConfig.chained === 'on') {
        console.warn('Chained mode is enabled, use ChainedDockedAd instead.');
        return;
      }
      // Locate target element using XPath
      const element = document.evaluate(
        dockedConfig.xpath,
        document,
        null,
        XPathResult.FIRST_ORDERED_NODE_TYPE,
        null
      ).singleNodeValue;
      if (element == null) {
        console.error('Element not found for the given XPath');
        return;
      }
      // Create a wrapper container for docked ads
      this.container = document.createElement('ins');
      this.container.className = 'undrads ua-docked-container';
      element.after(this.container);
      this.createAdContainers();
    }
    createAdContainers() {
      var _a;
      if (!this.container) return;
      this.container.innerHTML = '';
      this.adContainers = [];
      for (const [index, [adId]] of Object.entries(this.adUnits).entries()) {
        const adDiv = document.createElement('div');
        const adElementId = utils.getHashedId(adId);
        adDiv.id = adElementId;
        adDiv.className = 'ua-docked';
        const adSize = utils.getAdSizeFromElement(adId) || '300X250';
        const [width, height] = adSize.split('X').map(Number);
        if (isNaN(width) || isNaN(height)) {
          console.error(`Invalid ad size for ad ID: ${adId}`);
          continue;
        }
        // Apply styles for sticky docked ads
        adDiv.style.cssText = `
              width: ${width}px;
              height: ${height}px;
              margin-bottom: 10px;
              position: sticky;
              top: ${10 + index * (height + 10)}px;
            `;
        (_a = this.container) === null || _a === void 0 ? void 0 : _a.appendChild(adDiv);
        this.adContainers.push(adDiv);
        this.adElementIds.push(adElementId);
      }
    }
    init() {
      return this.adElementIds;
    }
    destroy() {
      var _a;
      (_a = this.container) === null || _a === void 0 ? void 0 : _a.remove();
      this.adContainers = [];
    }
  }

  /**
   * @fileoverview Handles analytics tracking, currently using fetch to send data.
   */
  class Analytics {
    /**
     * Sends a pageview event to the analytics endpoint.
     */
    static async sendPageview() {
      try {
        const response = await fetch(CONFIG.ENDPOINTS.PAGEVIEW, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify([{ domain: CONFIG.PUBLISHER_DOMAIN, country: CONFIG.COUNTRY }]),
        });
        if (!response.ok) {
          throw new Error(`Failed to send pageview: ${response.status}`);
        }
        logger.success('Pageview event sent successfully.');
      } catch (error) {
        logger.error('Error sending pageview event:', error);
      }
    }
  }

  /**
   * @fileoverview Initializes and manages interactions with the Google Tag (gtag.js).
   */
  class GTag {
    /**
     * Creates a new instance of the GoogleTag class and initializes it.
     * This is a private constructor to implement the singleton pattern.
     * @private
     */
    constructor() {}
    /**
     * Initializes the Google Tag Manager (gtag.js).
     * Sets up the data layer and configures gtag with the user ID.
     * @returns {void}
     */
    initialize() {
      var _a, _b;
      var _c;
      logger.info('Initializing GTAG...');
      (_a = window.dataLayer) !== null && _a !== void 0 ? _a : (window.dataLayer = []);
      // Define the gtag function
      (_b = (_c = window).gtag) !== null && _b !== void 0
        ? _b
        : (_c.gtag = function gtag(...args) {
            window.dataLayer.push(...args);
          });
      window.gtag('js', new Date());
      window.gtag('config', CONFIG.GTAG_USER_ID);
      window.gtag('get', CONFIG.GTAG_USER_ID, 'client_id', (clientId) => {
        if (clientId) {
          const UUID = utils.createUUID(clientId, 22);
          window.gtag('set', {
            dimension7: clientId,
            dimension8: clientId,
            dimension9: UUID,
          });
          const deviceDetails = utils.getDeviceDetails();
          if (googletag.cmd == null) {
            logger.error('googletag.cmd doesnt exists.');
          }
          googletag.cmd.push(() => {
            googletag.pubads().set('page_url', CONFIG.PUBLISHER_DOMAIN);
            googletag
              .pubads()
              .setTargeting('ua_site_url', CONFIG.PUBLISHER_DOMAIN)
              .setTargeting('ua_site_language', 'n/a')
              .setTargeting('ua_content_cat', 'n/a')
              .setTargeting('ua_format', 'pnp')
              .setTargeting('ua_device_name', deviceDetails.deviceType)
              .setTargeting('ua_browser_name', deviceDetails.browserName)
              .setTargeting('ua_os', deviceDetails.operatingSystem)
              .setTargeting('ua_browser_lang', deviceDetails.browserLanguage);
            googletag.pubads().setPublisherProvidedId(UUID);
          });
        } else {
          logger.error('Failed to retrieve ga_client_id for PPID generation.');
        }
      });
      logger.success('GTAG initialized.');
    }
    /**
     * Returns the singleton instance of the GoogleTag class.
     * Creates the instance if it doesn't exist.
     * @static
     * @returns The GoogleTag instance.
     */
    static getInstance() {
      if (GTag.instance == null) {
        GTag.instance = new GTag();
      }
      return GTag.instance;
    }
  }

  /**
   * @fileoverview Main entry point for the UndrAds script.
   * Initializes the script and sets up the ad manager, event listeners, and analytics.
   * Also provides a public API for triggering ad units.
   */
  var _a, _b, _c, _d, _e, _f, _g;
  var _h;
  // Initialize global objects
  (_a = window.dataLayer) !== null && _a !== void 0 ? _a : (window.dataLayer = []);
  (_b = window.googletag) !== null && _b !== void 0 ? _b : (window.googletag = {});
  (_c = window.uapbjs) !== null && _c !== void 0 ? _c : (window.uapbjs = {});
  (_d = window.googlefc) !== null && _d !== void 0 ? _d : (window.googlefc = {});
  (_e = (_h = window.googlefc).ccpa) !== null && _e !== void 0 ? _e : (_h.ccpa = {});
  (_f = window.undrads) !== null && _f !== void 0 ? _f : (window.undrads = {});
  (_g = window.videojs) !== null && _g !== void 0 ? _g : (window.videojs = {});
  // Initialize global objects
  const adManager = AdUnitManager.getInstance();
  /**
   * Loads all required scripts for UndrAds.
   * @returns {Promise<void>}
   */
  const loadAndPrepareGPT = async () => {
    try {
      // Load GFC first and wait for it to initialize
      await utils.loadScript(CONFIG.ENDPOINTS.GFC);
      if (CONFIG.STATUS.SERVICES.GPT) {
        // Using retry mechanism specifically for GPT
        await utils.loadScriptWithRetry(CONFIG.ENDPOINTS.GPT, 2, 500);
        GPT.enableServices();
        adManager.init();
      }
      // Using retry mechanism specifically for Prebid
      await utils.loadScriptWithRetry(CONFIG.ENDPOINTS.PREBID, 2, 1000);
    } catch (error) {
      // Even if Prebid fails, we don't want to break the entire ad system
      // Log the error but don't throw it
      logger.error('Error loading all scripts:', error);
    }
  };
  function loadStickyAds() {
    // Load sticky ads
    for (const [adId, adUnit] of Object.entries(CONFIG.AD_UNITS)) {
      const currentDeviceType = utils.getDeviceDetails().deviceType;
      if (adUnit.isSticky === 'on' && adUnit.StickyDeviceType === currentDeviceType) {
        // Form a new div element for the sticky ad
        const stickyContainer = document.createElement('ins');
        stickyContainer.setAttribute('data-ad-id', adId);
        stickyContainer.id = utils.getHashedId(adId);
        document.body.appendChild(stickyContainer);
        // Initialize the sticky ad
        adManager.loadAd(adUnit, stickyContainer.id, AdType.STICKY);
        break;
      }
    }
  }
  function loadInterstitialAds() {
    // Load interstitial ads
    for (const [adId, adUnit] of Object.entries(CONFIG.AD_UNITS)) {
      if (adUnit.isInterstitial === 'true') {
        // Form a new div element for the interstitial ad
        const interstitialContainer = document.createElement('ins');
        interstitialContainer.setAttribute('data-ad-id', adId);
        interstitialContainer.id = utils.getHashedId(adId);
        document.body.appendChild(interstitialContainer);
        // Initialize the interstitial ad
        adManager.loadAd(adUnit, interstitialContainer.id, AdType.INTERSTITIAL);
        break;
      }
    }
  }
  function loadDockedAds() {
    const dockedAd = new DockedAd(CONFIG.DOCKED_AD_UNITS);
    const adElementIds = dockedAd.init();
    for (const adElementId of adElementIds) {
      // [Key: InternalAdUnitId, Value: AdUnitConfig]
      // if the key contains the adElementId, then return the corresponding AdUnitConfig
      const adUnit = Object.entries(CONFIG.DOCKED_AD_UNITS.adUnits).find(([key]) =>
        adElementId.includes(key)
      );
      if (adUnit != null) {
        const [, adUnitConfig] = adUnit;
        logger.debug('Loading docked ad with config:', adUnitConfig);
        logger.debug('Loading docked ad with element ID:', adElementId);
        adManager.loadAd(adUnitConfig, adElementId, AdType.DOCKED);
      } else {
        logger.error(`Ad unit not found for element ID: ${adElementId}`);
      }
    }
  }
  const initUndrAds = async () => {
    var _a;
    try {
      // Add cleanup before initialization
      if (((_a = window.undrads) === null || _a === void 0 ? void 0 : _a.cleanup) != null) {
        window.undrads.cleanup();
      }
      logger.showWelcomeBanner();
      if (CONFIG.URL_BLOCK.some((url) => window.location.href.includes(url))) {
        logger.info('UndrAds is blocked on this URL. Exiting..');
        return;
      }

      // Find country - with timeout
      const countryPromise = utils.getCountryFromCDNResponse(CONFIG.ENDPOINTS.PREBID);
      CONFIG.COUNTRY = await Promise.race([
        countryPromise,
        new Promise((resolve) => setTimeout(() => resolve('N/A'), 3000)),
      ]);
      await Analytics.sendPageview();

      CONFIG.AD_UNITS = getAdUnitsWithBidders({ countryLevel: true, country: CONFIG.COUNTRY });
      CONFIG.CURRENCY.DEFAULT = 'AED';
      CONFIG.CURRENCY.MULTIPLIER = 3.67;

      await loadAndPrepareGPT();
      window.uapbjs.setConfig({
        debug: isDebugMode(),
      });
      if (CONFIG.STATUS.ADS.VIDEO) {
        await VideoAd.loadStyleSheets();
        await VideoAd.loadScripts();
      }
      if (CONFIG.STATUS.SERVICES.GTAG) {
        await utils.loadScript(CONFIG.ENDPOINTS.GTAG);
      }
      // Initialize services
      if (CONFIG.STATUS.SERVICES.GTAG) {
        GTag.getInstance().initialize();
      }
      const prebidManager = new PrebidManager();
      await prebidManager.initialise();

      if (CONFIG.STATUS.ADS.AMAZON) {
        const amazonAds = new AmazonAds(CONFIG.AMAZON_PUB_ID);
        amazonAds.initializeAmazon();
      }

      prebidManager.sendAnalytics();

      logger.success('UndrAds initialized successfully.');
    } catch (error) {
      logger.error('Error during UndrAds initialization:', error);
    }
  };
  function getDeviceSpecificAdElement(insElement) {
    var _a, _b, _c;
    const elementAdId =
      (_a =
        insElement === null || insElement === void 0
          ? void 0
          : insElement.getAttribute('data-ad-id')) !== null && _a !== void 0
        ? _a
        : '';
    let newAdUnitId = undefined;
    const isCurrentAdUnitSticky =
      (_c =
        (_b = CONFIG.AD_UNITS[elementAdId]) === null || _b === void 0 ? void 0 : _b.isSticky) !==
        null && _c !== void 0
        ? _c
        : 'off';
    const currentAdSize = utils.getAdSizeFromElement(elementAdId);
    let newAdUnitSize = [currentAdSize];
    logger.debug('Current ad size:', currentAdSize);
    // Check if the device is mobile
    // And, if the ad unit contains desktop in the ad ID
    // Then, search for the mobile ad size in ResponsiveAdSizeMapping
    // And, return the mobile ad unit ID => mobile/320X100
    if (utils.isMobileSize()) {
      logger.info('Device is mobile.');
      // Check if the device is mobile
      if (elementAdId.includes(DeviceType.DESKTOP)) {
        logger.info('Ad unit is desktop. Changing to mobile.');
        newAdUnitSize = CONFIG.AD_SIZE_MAPPING.DESKTOP_TO_MOBILE[currentAdSize];
        if (newAdUnitSize == null) {
          logger.info('No ad size mapping found for:', currentAdSize);
          return insElement;
        }
        logger.debug('New ad size:', newAdUnitSize);
        newAdUnitId = utils.getDeviceSpecificAdKey(
          DeviceType.MOBILE,
          newAdUnitSize,
          isCurrentAdUnitSticky
        );
        logger.debug('New ad unit:', newAdUnitId);
      }
    } else {
      logger.info('Device is Desktop.');
      // Check if the device is desktop
      if (elementAdId.includes(DeviceType.MOBILE)) {
        logger.info('Ad unit is mobile. Changing to desktop.');
        newAdUnitSize = CONFIG.AD_SIZE_MAPPING.MOBILE_TO_DESKTOP[currentAdSize];
        if (newAdUnitSize == null) {
          logger.info('No ad size mapping found for:', currentAdSize);
          return insElement;
        }
        logger.debug('New ad size:', newAdUnitSize);
        newAdUnitId = utils.getDeviceSpecificAdKey(
          DeviceType.DESKTOP,
          newAdUnitSize,
          isCurrentAdUnitSticky
        );
        logger.debug('New ad unit:', newAdUnitId);
      }
    }
    if (newAdUnitId != null) {
      insElement === null || insElement === void 0
        ? void 0
        : insElement.setAttribute('data-ad-id', newAdUnitId);
      insElement === null || insElement === void 0
        ? void 0
        : insElement.setAttribute('id', utils.getHashedId(newAdUnitId));
    }
    return insElement;
  }
  function loadAdsInBodyTag() {
    // Create video element if it doesn't exist
    VideoAd.createVideoElement();
    // Get all ad slots
    const adSlots = document.querySelectorAll('.undrads[data-ad-id]');
    logger.debug('Total Body Ad slots:', adSlots);
    for (const adSlot of Array.from(adSlots)) {
      // Get the ad slot ID
      const adSlotId = adSlot.getAttribute('data-ad-id');
      logger.debug('Ad slot:', adSlot);
      if (adSlotId == null) {
        logger.error('Ad slot ID not found.');
        continue;
      }
      let adElement = getDeviceSpecificAdElement(adSlot);
      logger.debug('Ins element after device check:', adElement);
      const elementAdId = utils.getElementAdId(adElement);
      // Check what type of ad unit is being pushed from class name
      const adType = utils.getAdTypeFromClassName(adElement);
      // If the ad type is video, then get the first child element
      if (adType === AdType.VIDEO) {
        adElement =
          adElement === null || adElement === void 0 ? void 0 : adElement.firstElementChild;
      }
      if (adElement != null && elementAdId != null) {
        adElement.id = utils.getHashedId(elementAdId);
        adManager.triggerAd(adElement, elementAdId, adType);
      } else {
        logger.error('Error getting ins element or ad code.');
      }
    }
  }
  function loadALlAds() {
    loadAdsInBodyTag();
    if (CONFIG.STATUS.ADS.STICKY) {
      loadStickyAds();
    }
    if (CONFIG.STATUS.ADS.INTERSTITIAL) {
      loadInterstitialAds();
    }
    if (CONFIG.STATUS.ADS.DOCKED) {
      loadDockedAds();
    }
    // Initialize header bidding for external ads
    if (CONFIG.STATUS.ADS.PROPERTY.HEADER_BIDDING_EXTERNAL_ADS) {
      const headerBiddingManager = HeaderBiddingManager.getInstance();
      headerBiddingManager.processHeaderBiddingOnExternalAds();
    }
    if (CONFIG.STATUS.ADS.PROPERTY.REPLACE_EXTERNAL_ADS) {
      adManager.initReplacement();
    }
  }
  function start() {
    let initialized = false;
    return async () => {
      if (initialized) return;
      initialized = true;
      try {
        await initUndrAds();
        loadALlAds();
        logger.success('All ads loaded successfully.');
      } catch (error) {
        logger.error('Error initializing UndrAds:', error);
        initialized = false;
      }
    };
  }
  window.undrads = {
    ...window.undrads,
    cleanup: () => {
      adManager.cleanup();
      // Clear any global event listeners
      window.removeEventListener('scroll', () => {});
      window.removeEventListener('resize', () => {});
    },
    init: async () => {
      logger.debug('Init Hook Called!');
      await initUndrAds();
    },
    displayAd: (adElement, adUnitId) => {
      logger.debug('Display Ad Hook Called!');
      console.log('[UndrAds]: Display Ad Hook Called!');
      if (adElement == null) {
        logger.error('Ad element not found.');
        console.log('[UndrAds]: Ad element not found. Cannot display ad.');
        console.info(
          '[UndrAds]: Expected implementation: window.undrads.displayAd(adElement, adUnitId);'
        );
        return;
      }
      if (adUnitId == null) {
        logger.error('Ad unit ID not provided.');
        console.log('[UndrAds]: Ad unit ID not provided. Cannot display ad.');
        console.info(
          '[UndrAds]: Expected implementation: window.undrads.displayAd(adElement, adUnitId);'
        );
        return;
      }
      adManager.triggerAd(adElement, adUnitId, AdType.STRUCTURAL);
    },
  };
  const startOnce = start();
  if (document.readyState === 'loading') {
    document.addEventListener(
      'DOMContentLoaded',
      () => {
        void startOnce();
      },
      { once: true }
    );
  } else {
    void startOnce();
  }

  exports.initUndrAds = initUndrAds;
  exports.loadAdsInBodyTag = loadAdsInBodyTag;
  exports.loadDockedAds = loadDockedAds;
  exports.loadInterstitialAds = loadInterstitialAds;
  exports.loadStickyAds = loadStickyAds;

  return exports;
})({});
